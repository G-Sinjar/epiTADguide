---
title: "fertige pipline"
author: "Ghazal Sinjar"
date: "2024-12-16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document.


# library
```{r}
library(minfi)
#library("IlluminaHumanMethylationEPICv2manifest")
#library(IlluminaHumanMethylationEPICv2anno.20a1.hg38)
# both libraries are automaticaly loaded when they are needed
library(readxl)
```

# Reading the SampleSheet file
```{r}
# Note the folder you provide should have the sampleSheet excel table and another folder where the red and Green row idat files are saved
RawDataDir <- "C:\\Users\\ghaza\\Documents\\ghazal\\Bioinformatik_Fächer\\Masterarbeit_Project\\Data\\CLDN10_RawData\\epic_data\\2024_071_ILL_METUVG_N_8\\METUVG"

targets <- read.metharray.sheet(RawDataDir) 
View(targets)
# should the samplesheet be csv like in our dataset? # check also the columns some must be there 
#if you get theis messege "[read.metharray.sheet] Found the following CSV files:" then IT WORKED 
#Contains all probes, including:Quality control probes, Out-of-band probes, Control probes--> Dimensions: more probes than will be used for methylation analysis.
#writexl::write_xlsx(targets, "./Output/Samples-targets.xlsx")
```


# Load methydata from idat files 
```{r}
RGset <- read.metharray.exp(targets = targets)
#head(RGset) #1105209 # assays red + green
#load("C:\\Users\\ghaza\\Documents\\ghazal\\Bioinformatik_Fächer\\Masterarbeit_Project\\Scripts\\R_Scripts/RGset_SWAN_normalised.RData")

#manifest <- getManifest(RGset)
#manifest
annotation(RGset)
## duplicates finding
#probeIDs <- featureNames(RGset)  # For RGChannelSet or MethylSet
#anyDuplicated(probeIDs)


raw_normalised <- preprocessRaw(RGset)
raw_normalised # assays: Meth + Unmeth #936990
annotation(raw_normalised)
pData(raw_normalised)
#These objects contain only the probes with usable methylation data:
```

# Quality control:
## 1-  raw Intensities plot 
```{r}
#png("./Plots/red_green_channel_plot.png", width = 800, height = 600)
plot(density(as.vector(assay(RGset, "Red"))), main = "Channel Intensities", lwd = 2) 
lines(density(as.vector(assay(RGset, "Green"))), col = "green", lwd = 2)
legend("topright", legend = c("Red Channel", "Green Channel"), col = c("black", "green"), lwd = 2)
#dev.off()
```

## 2- sample-specific QC
```{r}
qc <- getQC(raw_normalised)
#qc   # log2 Medien plot: Methy and unmeth intensities
raw_normalised <- addQC(raw_normalised, qc)
plotQC(qc)
#pData(raw_normalised)
```

## 3- MDS plot (multi dimensional scaling plot)
```{r}
par(mfrow = c(2, 3), mar = c(1.7, 1.7, 1.4, 0.4)) 
mdsPlot(RGset, sampNames = targets$Array, sampGroups = targets$Sample_Group ,main = "Raw Beta MDS", legendNCol = 1, legendPos = "topright")

mdsPlot(noob_normalised, sampNames = targets$Array, sampGroups = targets$Sample_Group, main = "noob Beta MDS", legendNCol = 1, legendPos = "topright")
mdsPlot(SWAN_normalised, sampNames = targets$Array, sampGroups = targets$Sample_Group, main = "SWAN Beta MDS", legendNCol = 1 ,legendPos = "topright")
mdsPlot(getBeta(funnorm_normalised), sampNames = targets$Array, sampGroups = targets$Sample_Group, main = "funnorm Beta MDS", legendNCol = 1,legendPos = "topright")
mdsPlot(getBeta(Quantile_normalised), sampNames = targets$Array, sampGroups = targets$Sample_Group, main = "Quantile Beta MDS ", legendNCol = 1,legendPos = "topright")
```

## 4- Badewanne plot: Beta plot (probability density plot)
```{r}
## raw data
densityPlot(RGset, sampGroups = targets$Sample_Label, main ="Beta values distribution of raw data", xlab = "Beta values")

### Bean plot 
par(mar = c(5, 6, 4, 2)) # Bottom, left, top, right margins (default is c(5, 4, 4, 2))
densityBeanPlot(RGset, sampGroups = targets$Sample_Label, sampNames = targets$Sample_Name)

### QC report
qcReport(RGset, sampNames = targets$Sample_Name, sampGroups = targets$Sample_Group0, pdf = "qcReport.pdf" )

# Badewanne mit probe types
pdf("plot_comparison.pdf", width=12, height=6)  # Larger PDF
par(mfrow=c(1,2))
plotBetasByType(raw_normalised[,1], main = "Raw")
plotBetasByType(SWAN_normalised[,1], main = "SWAN")
dev.off() 
```


# Normalisation
```{r}
preprocessed_data <- readRDS("./intermediate_data/preprocessed_data.rds")
RGset <- preprocessed_data$RGset
targets <- preprocessed_data$targets


Quantile_normalised <- preprocessQuantile(RGset, fixOutliers = TRUE,removeBadSamples = TRUE, badSampleCutoff = 10.5, quantileNormalize = TRUE, stratified = TRUE, mergeManifest = FALSE, sex = NULL)

Quantile_normalised$predictedSex # all F??

b <- getBeta(Quantile_normalised)

# other normalisation Methods
funnorm_normalised <- preprocessFunnorm(RGset)
noob_normalised <- preprocessNoob(RGset)
set.seed(123)
noob.swan_normalised <- preprocessSWAN(RGset, mSet = noob_normalised, verbose = TRUE)
set.seed(123)
SWAN_normalised <- preprocessSWAN(RGset, raw_normalised)

# new noob.quantile
noob_quantile <- preprocessQuantile(noob_normalised,fixOutliers = TRUE,removeBadSamples = TRUE, badSampleCutoff = 10.5, quantileNormalize = TRUE, stratified = TRUE, mergeManifest = FALSE, sex = NULL)


#save(RGset, SWAN_normalised, file = "RGset_SWAN_normalised.RData")
```

## Beta values Badewanne plot
```{r}
densityPlot(raw_normalised,sampGroups = targets$Sample_Label,main = "Beta Values distribution after raw normalisation", pal = rainbow(length(unique(targets$Sample_Label))))

densityPlot(noob_normalised, sampGroups = targets$Sample_Label ,main = "Beta values distribution after Noob", pal = rainbow(length(unique(targets$Sample_Label))))

densityPlot(funnorm.beta_values,sampGroups = targets$Sample_Label,main = "Beta Values distribution after Funnorm normalisation", pal = rainbow(length(unique(targets$Sample_Label))))

densityPlot(Quantile.beta_values,sampGroups = targets$Sample_Label,main = "Beta Values distribution after Quantile normalisation", pal = rainbow(length(unique(targets$Sample_Label))))

densityPlot(SWAN_normalised, sampGroups = targets$Sample_Label , main = "Beta values distribution after SWAN normalisation", pal = rainbow(length(unique(targets$Sample_Label))))

densityPlot(noob.swan_normalised,sampGroups = targets$Sample_Label, main = "Beta values distribution after Noob-SWAN", pal = rainbow(length(unique(targets$Sample_Label))))

# new try
densityPlot(getBeta(noob_quantile),sampGroups = targets$Sample_Label, main = "Beta values distribution after Noob-Quantile", pal = rainbow(length(unique(targets$Sample_Label))))
```



# filter and map steps
## 1. Filtering unreliable CPGs (p-value 0,01 immer)
```{r}
#---------------first level filtering: cpgs that passed the threshold in all samples --> sample reliability----------
detectp <- detectionP(RGset)
#dim(detectp) #936990      8


if (all.equal(row.names(SWAN_normalised), row.names(detectp))){
  absent <- apply(detectp, 1, function(x) sum(x>0.01)) 
  table(absent) #-> 911931 -_>  97.32559%
}
swan_filtered <- SWAN_normalised[absent == 0] # 911931 


# FUNNORM and quantile
if (isTRUE(all.equal(row.names(funnorm_normalised), row.names(detectp)))) {
  absent <- apply(detectp, 1, function(x) sum(x > 0.01))
  print(table(absent)) # Ausgabe der Tabelle
  # table(absent) #-> 911931 -_>  97.32559%
} else {
  # Optional: Wenn die Zeilennamen nicht übereinstimmen, können Sie hier eine Meldung ausgeben
  warning("Zeilennamen stimmen nicht überein! all.equal-Ergebnis: ", all.equal(row.names(funnorm_normalised), row.names(detectp)))
}
--------------------------------------------------------------------------------------------

# function to filter both methylset and GenomicRatioSet 
library(minfi)
library(GenomicRanges)

filter_by_detectionP <- function(normalized_object, RGset) {

  detectp <- detectionP(RGset)
  
  # OPTIMIZATION: Vectorized identification of unreliable probes
  # This is much faster than apply(..., function(x) any(x > 0.01))
  unreliable_probes_mask <- rowSums(detectp > 0.01) > 0 
  
  unreliable_probe_names <- rownames(detectp)[unreliable_probes_mask]
  normalized_object_probe_names <- rownames(normalized_object)
  
  # Check if the normalized object is a minfi S4 object that commonly alters probe sets/order.
  is_minfi_S4_object <- inherits(normalized_object, "GenomicRatioSet") ||
                        inherits(normalized_object, "MethylSet") ||
                        inherits(normalized_object, "MSet") ||
                        inherits(normalized_object, "RGChannelSet") # Raw data itself also might be normalized_object
  
  # OPTIMIZATION: Reorder the if/else for efficiency.
  # Prefer direct logical subsetting if conditions allow (fastest path).
  # Conditions: Not an S4 object (known to reorder) AND row names explicitly match.
  can_do_direct_subset <- !is_minfi_S4_object && isTRUE(all.equal(normalized_object_probe_names, rownames(detectp)))

  if (can_do_direct_subset) {
    message("Applying detection P-value filtering using direct logical subsetting (row names match).")
    # Direct subsetting, assuming the order and presence of probes matches detectp
    filtered_object <- normalized_object[!unreliable_probes_mask, ]
  } else {
    message("Applying detection P-value filtering using probe name intersection (likely S4 object or mismatch).")
    # This is the more robust path, using setdiff for name-based filtering
    probes_to_keep <- setdiff(normalized_object_probe_names, unreliable_probe_names)
    filtered_object <- normalized_object[probes_to_keep, ]
  }
  
  message(paste0("Original probes: ", nrow(normalized_object), 
                 ". Probes after detection P-value filtering: ", nrow(filtered_object), "."))
                 
  return(filtered_object)
}


# test fuction
filtered <- filter_by_detectionP(Quantile_normalised, RGset)
filtered #class: GenomicRatioSet dim: 905075 8 
```

## 2. Map to the Genome:
```{r}
Geno_filtered <- mapToGenome(filtered, mergeManifest = TRUE)
#dim(Geno_SWAN_filtered) #905075
# assays methy unmethyl

'Geno_filtered.
class: GenomicRatioSet 
dim: 905075 8'
mapToGenome()
```

## 3. removing SNPs 
```{r}
# remove snps if needed
ratio_geno_swan__NoSNP <- dropLociWithSnps(Geno_filtered, snps = c("SBE", "CpG"), maf = 0)
#891492    8

#ratio_geno_NoSNP
#class: GenomicRatioSet dim: 891492 8

# SNPs infos if snps should be removed then the input=  ratio_geno_Swan_NoSNP else = Geno_SWAN_filtered
snps <- getSnpInfo(ratio_geno_NoSNP)
#View(as.data.frame(snps))
# adding the snps to the annotation/mapping infos as metadata if snps removed then add just the first 2 col else all columns
ratio_geno_Swan <- addSnpInfo(ratio_geno_NoSNP)


# for stats: input is the output of the both stes above
granges_snp <- rowRanges(ratio_geno_Swan_NoSNP) # no need
# number of cpg snps left
sum(!is.na(granges_snp$CpG_maf)) #0
# number of SNP at the Single Base Extension (SBE) site. This site is relevant in the chemistry of the assay, affecting signal detection.
sum(!is.na(granges_snp$SBE_maf)) #0
# number of snps in the probe
sum(!is.na(granges_snp$Probe_rs)) # 164776


# fazit: #  if snp should be deleted no need to add info or add just the first 2 columns  (Probe_rs, Probe_maf) 
```

# sex prediction
```{r}
'#Note: the function does not handle datasets with only females or only males. i guess thats why u get a warning
 #Warning in .getSex(CN = CN, xIndex = xIndex, yIndex = yIndex, cutoff = cutoff) :
  An inconsistency was encountered while determining sex. One possibility is that only one sex is present. We recommend further checks, for example with the plotSex function.'

# predict sample sex 
predictedSex <- getSex(ratio_geno_Swan, cutoff = -2)
predictedSex

# add sex to pdata
ratio_geno_Swan_sex <- addSex(ratio_geno_Swan, sex = predictedSex)
pData(ratio_geno_Swan_sex)
```

# remove Probes on sex chromosomes
```{r}
library(GenomicRanges)

# Extract rowRanges (probe genomic coordinates)
granges <- rowRanges(ratio_geno_Swan_sex)

# Check seqnames (chromosome) for first few probes
head(seqnames(granges))

# Filter to keep only autosomal probes (not on X or Y)
autosomal_probes <- !(seqnames(granges) %in% c("chrX", "chrY"))

# Subset the GenomicRatioSet object to keep autosomal probes only
ratio_geno_Swan_autosomal <- ratio_geno_Swan_sex[autosomal_probes, ]

# Check dimensions before and after
dim(ratio_geno_Swan_sex) -dim(ratio_geno_Swan_autosomal)
```



# Convert GenoMethylSet to a GenoRatioSet (Beta + M): 
```{r}
ratio_geno_Swan <- ratioConvert(ratio_geno_NoSNP,what = "both", keepCN= TRUE)
#dim(ratio_geno_Swan) #905075      8
```



# stats table
```{r}
# Get row counts
raw_n <- nrow(raw_normalised)
reliable_n <- nrow(SWAN_filtered)
mapped_n <- nrow(Geno_SWAN_filtered)
no_snp_n <- nrow(ratio_geno_Swan_NoSNP)
snp_n <- nrow(ratio_geno_Swan) - no_snp_n

# Create matrix or data frame
stats <- data.frame(
  "Number of CpGs" = c(raw_n, reliable_n, mapped_n, snp_n, no_snp_n),
  "% from raw" = round(c(
    100,
    reliable_n / raw_n * 100,
    mapped_n / raw_n * 100,
    snp_n / raw_n * 100,
    no_snp_n / raw_n * 100
  ), 2)
)

rownames(stats) <- c("Raw data", "Reliable CpGs", "Mapped CpGs", "CpGs representing SNPs", "CpGs without SNPs")
stats
```



# Annotation data
```{r}
annotation <- getAnnotation(ratio_geno_Swan_NoSNP)
#dim(annotation) #891492     42 -> 100%

annotation_df <- as.data.frame(annotation)
#View(annotation_df)


ratio_geno_Swan_NoSNP_Beta <- getBeta(ratio_geno_Swan_NoSNP)

# 2. Combine methylation values with annotation:
if (identical(rownames(annotation_df),rownames(ratio_geno_Swan_NoSNP_Beta))){ 
    annotated_with_betas <- cbind(annotation, ratio_geno_Swan_NoSNP_Beta)
} 
#dim(annotated_with_betas) #  896581     50
annotated_with_betas_df <- as.data.frame(annotated_with_betas)
View(annotated_with_betas_df)
```

# retreat tables
```{r}
Swan_0.01_Beta_rownames <- cbind(CpGs = rownames(ratio_geno_Swan_NoSNP_Beta), ratio_geno_Swan_NoSNP_Beta)
writexl::write_xlsx(Swan_0.01_Beta_rownames, "./Output/2-Beta_values_SWAN_0.01.xlsx", col_names = TRUE)

M_values_0.01_df_rownames <- cbind(CpGs = rownames(M_values_0.01_df), M_values_0.01_df)
writexl::write_xlsx(M_values_0.01_df_rownames, "./Output/3-M_values_SWAN_0.01.xlsx", col_names = TRUE)


annotated_with_betas_rownames <- cbind(CpGs = rownames(annotated_with_betas_df), annotated_with_betas_df)
writexl::write_xlsx(annotated_with_betas_rownames, "./Output/4-annotation_0.01_with_betas.xlsx", col_names = TRUE)

CpGs_CLDN10_with_rownames <- cbind(CpGs = rownames(CpGs_CLDN10), CpGs_CLDN10)
writexl::write_xlsx(CpGs_CLDN10_with_rownames, "./Output/5-CpGs_of_CLDN10.xlsx", col_names = TRUE)
```

# get lage auf dem Chr -> file from ucsc -> the lines dont have a consistence length -> didnt work
```{r}
library(rtracklayer)
library(dplyr)

# Define the local path where the file should be saved
local_file_path <- "cytoBand_hg38.txt.gz"
url <- "http://hgdownload.cse.ucsc.edu/goldenpath/hg38/database/cytoBand.txt.gz"

# Check if the file already exists locally
if (!file.exists(local_file_path)) {
  # If the file does not exist, download it
  download.file(url, destfile = local_file_path)
  cat("File downloaded.\n")
} else {
  cat("File already exists locally.\n")
}
```


# get chromosomal band from ensembl -> didnt work
```{r}
library(biomaRt)

# Connect to Ensembl biomart
ensembl <- useEnsembl(biomart = "ENSEMBL_MART_ENSEMBL", dataset = "hsapiens_gene_ensembl", GRCh = 38)
# didnt work erscheint the webseit is not working


# Get the cytoband information
cytobands_ensembl <- getBM(
  attributes = c("chromosome_name", "start_position", "end_position", "band"),
  mart = ensembl
)

# Rename columns to match UCSC style
colnames(cytobands_ensembl) <- c("chrom", "chromStart", "chromEnd", "name")

# Remove non-standard chromosomes (like patches and alternative sequences)
cytobands_ensembl <- cytobands_ensembl[grepl("^\\d+$|^X$|^Y$", cytobands_ensembl$chrom), ]

# Convert chromosome numbers to UCSC format (e.g., "1" → "chr1")
cytobands_ensembl$chrom <- paste0("chr", cytobands_ensembl$chrom)

# Check results
head(cytobands_ensembl)

```




# get cytoband from sigminer
```{r}
#install.packages("sigminer")
library(sigminer)

cytobands_hg38 <- sigminer::cytobands.hg38

View(cytobands.hg38)
```

# add the cytobands to annotation table --> didnt work until now -> maybe add in another step where the table is smaller
```{r}
library(dplyr)

# Ensure pos, start, and end are numeric
annotation_df$pos <- as.numeric(annotation_df$pos)
cytobands_hg38$start <- as.numeric(cytobands_hg38$start)
cytobands_hg38$end <- as.numeric(cytobands_hg38$end)

# Merge annotation_df with cytobands, keeping all rows from annotation_df
annotation_df <- annotation_df %>%
  left_join(cytobands_hg38 %>%
              select(chrom, start, end, band), by = c("chr" = "chrom")) %>%
  mutate(band = ifelse(pos >= start & pos <= end, band, NA)) %>%
  select(-start, -end)  # Drop the start and end columns from the final output

# View the result
head(annotation_df)



######################### Another way ##############
library(dplyr)

# Step 1: Create a new column in annotation_df to store the matching band
annotation_df$band <- NA

# Step 2: Group cytobands by chromosome
cytobands_grouped <- cytobands_hg38 %>%
  group_by(chrom) %>%
  arrange(start, end)  # Optional: arrange cytobands in order of start and end positions

# Step 3: Loop through each row of annotation_df
for (i in 1:nrow(annotation_df)) {
  # Get the row's chromosome and position
  chr <- annotation_df$chr[i]
  pos <- annotation_df$pos[i]
  
  # Find matching cytobands for the chromosome
  matching_cytobands <- cytobands_grouped %>%
    filter(chrom == chr)
  
  # Check if pos falls within the start and end range of any cytoband
  matching_band <- matching_cytobands %>%
    filter(start <= pos & end >= pos) %>%
    pull(band)
  
  # If a matching band is found, add it to the annotation_df row
  if (length(matching_band) > 0) {
    annotation_df$band[i] <- matching_band[1]  # Only add the first matching band
  }
}



# Check the result
View(annotation_df)



# save table
writexl::write_xlsx(annotation_df, "./Output/annotation_0.,01_cytoband.xlsx")
```
