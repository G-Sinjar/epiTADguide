---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.


# library
```{r}
library(minfi)
library(dplyr)
```

# Preparing for bumhunter
```{r}
# 1. Define the phenotype of interest
pheno <- pData(ratio_geno_Swan_NoSNP)$Sample_Group
# 2. Change the reference level to "unguided" so the value is minus on chr13 target
if (!is.factor(pheno)) {
  pheno <- factor(pheno)
}
pheno <- relevel(pheno, ref = "unguided")


# 3. designMatrix
designMatrix <- model.matrix(~ pheno)
```


# DMRs cutoff 0,15  B=100  smooth= FALSE
```{r}
library(doParallel)
registerDoParallel(cores = 4)

dmrs <- bumphunter(ratio_geno_Swan_0.05_NoSNP, design = designMatrix, cutoff = 0.15, B=100, type="Beta", maxGap = 500)

#dim(dmrs2$table) #1067   15
View(dmrs2$table)
```


# DMRs with cutoff=0.15,   B=100   smooth = TRUE
```{r}
library(doParallel)
registerDoParallel(cores = 6)
dmrs <- bumphunter(ratio_geno_Swan_NoSNP, design = designMatrix, cutoff = 0.15, B=0, type="Beta", smooth = TRUE) 
View(dmrs$table) # info u get pvalue only of B>0
#0,2 B=0 --> 1dmr chr6
#0,15 B=0 --> 16 DMR
#0,15 B=100 --> 16 DMR
```

# function: Editing the DMR table
```{r}
edit_dmr_table <- function(dmrs) {
  DMRtable <- dmrs$table
  
  # Add length column 
  DMRtable$length <- DMRtable$end - DMRtable$start
  
  # Order by length
  DMRtable <- DMRtable[order(DMRtable$length, decreasing = TRUE), ]
  
  # Add DMR_Nr
  DMRtable$DMR_Nr <- paste0("DMR", seq_len(nrow(DMRtable)))
  
  # Round numeric columns, but keep whole numbers as integers
  num_cols <- sapply(DMRtable, is.numeric)  # Identify numeric columns
  
  DMRtable[num_cols] <- lapply(DMRtable[num_cols], function(x) {
    if (all(x == floor(x))) {  # Check if all values are whole numbers
      return(as.integer(x))    # Keep them as integers
    } else {
      return(round(x, 5))      # Otherwise, round to 5 decimal places
    }
  })
  
  DMRtable <- DMRtable %>% rename(mean.methy.difference = value,
                                  CpGs.inDMR = L,
                                  CpGs.inCluster = clusterL)
  
  # Reorder columns safely
  desired_cols <- c("DMR_Nr", "chr", "start", "end", "length", 
                    "mean.methy.difference", "CpGs.inDMR", 
                    "CpGs.inCluster", "p.value", "fwer")
  available_cols <- names(DMRtable)
  column_order <- c(
    desired_cols[desired_cols %in% available_cols],
    setdiff(available_cols, desired_cols)
  )
  
  DMRtable <- DMRtable[, column_order, drop = FALSE]
  return(DMRtable)
}

dmrs_tbl <- edit_dmr_table(dmrs)
```

# save/ get DMR table
```{r}
writexl::write_xlsx(dmrs_0.01_smooth, "./Output/DMRs_0.01_smooth.xlsx")


# get dmrs_smooth from excel
library(readxl)
dmrs_smooth <- read_excel("./Output/8-DMRs_0.01_smooth.xlsx")
head(dmrs_smooth) 
```



# create boxplots for DMRs (with smoothing) ########################
## 1 bind to cpps DMR1 smooth
```{r}
# Binding to annotation table to get cpgs infos:
cpgs_DMR1 <- annotation_df[annotation_df$chr == "chr13" & 
                       annotation_df$pos >= dmrs_smooth$start[1]& 
                       annotation_df$pos <= dmrs_smooth$end[1], ]
View(cpgs_DMR1)
```
## 2 get dmp table
```{r}
View(dmp)

# get dmp_NoShrink from excel
library(readxl)
dmp <- read_excel("./Output/7-DMPs_NoShrink_0,01.xlsx")
View(dmp)
```

## 3 Add columns (pval, beta and M differnces) to the cpgs_DMR1 
```{r}
# 1. get-pvalue from dmp table
cpgs_DMR1_pval <- dmp[rownames(cpgs_DMR1), ]
View(cpgs_DMR1_pval)

identical(rownames(cpgs_DMR1_pval), rownames(cpgs_DMR1)) # true

# 2. Add the extracted values as new columns in cpgs_DMR1
cpgs_DMR1$P.Value <- cpgs_DMR1_pval$pval
cpgs_DMR1$Beta_Difference <- cpgs_DMR1_pval$beta_difference
cpgs_DMR1$M_Difference <- cpgs_DMR1_pval$M_difference

View(cpgs_DMR1)
```

## 4  DMR1 boxplot
### a-create a table for boxplot of cpgs in one DMR1  
```{r}
# create the box plot table
library(dplyr)

cpgs_DMR1_for_boxplot <- cpgs_DMR1 %>% select(chr, pos, strand, P.Value, 35:42)

View(cpgs_DMR1_for_boxplot)

# save and send to cornelia
writexl::write_xlsx(cpgs_DMR1_for_boxplot, "./Output/cpgs_in_DMR1_forBoxplots.xlsx")
```


### b-  creating a long format table ready for boxplots of all cpgs in one DMR
```{r}
library(tidyr)
beta_long_smooth <- cpgs_DMR1_for_boxplot %>%
  rowwise() %>%
  pivot_longer(
    cols = 5:12,  # Selecting beta value columns
    names_to = "SampleID",
    values_to = "BetaValue"
  ) %>%
  mutate(
    Group = pheno[match(SampleID, colnames(cpgs_DMR1_for_boxplot)[5:12])],  # Match sample to Group
    Position = rep(cpgs_DMR1_for_boxplot$pos, each = length(5:12)),
    CpGName = rownames(cpgs_DMR1_for_boxplot)[rep(1:nrow(cpgs_DMR1_for_boxplot), each = length(5:12))],
  ) %>%
  ungroup() %>%
  select(Position, SampleID, BetaValue, Group, CpGName)  # Select desired columns

# 0rder the cpgs according to pos
beta_long_smooth <- beta_long_smooth[order(beta_long_smooth$Position, decreasing = FALSE), ]

 
# add this column from dmps
beta_long_smooth <- beta_long_smooth %>%
  mutate(P.Value = cpgs_DMR1_for_boxplot$P.Value[match(CpGName, rownames(cpgs_DMR1_for_boxplot))])

beta_long_smooth <- beta_long_smooth %>%
  mutate(PositionLabel = paste(CpGName, "\n", "pval =", round(P.Value, 5)))

View(beta_long_smooth)

# save and send to cornelia
writexl::write_xlsx(beta_long_smooth, "./Output/longformat_cpgs_in_DMR1_forBoxplots.xlsx")
```

### c basic interactive Boxplots of cpgs in one DMR
```{r}
p2 <- ggplot(long_DMR1, aes(x = factor(PositionLabel), y = BetaValue, fill = Group)) +
  geom_boxplot(outlier.shape = NA) +  # Remove default outlier points
  geom_jitter(aes(color = Group, text = SampleID), width = 0.2, height = 0, shape = 16) +  # Add outlier points manually
  theme_minimal() +
  scale_fill_manual(values = c("guided" = "blue", "unguided" = "red")) +  # Custom colors
  labs(x = "CPG + Position on Chr13", y = "Beta Value", fill = "Group") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p2
interactive_plot2 <- ggplotly(p2)
interactive_plot2
```

### d interactiv boxplots: position on chr related  # PositionLabel oben
```{r}
# P3: distanz zwischen Boxes ist abhängig von echte Distanz 
p3 <- ggplot(beta_long_smooth, aes(x = Position, y = BetaValue, fill = Group)) +
  geom_boxplot(outlier.shape = NA, width = 2) +  
  geom_jitter(aes(color = Group), width = 0.2, height = 0, shape = 16) +  
  theme_minimal() +
  scale_fill_manual(values = c("guided" = "blue", "unguided" = "red")) +  
  labs(x = "Genomische Position auf Chr13", y = "Beta Value", fill = "Group") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  
  # PositionLabel über den Boxplots anzeigen
  geom_text(data = beta_long_smooth, 
            aes(x = Position, y = max(beta_long_smooth$BetaValue) + 0.05, 
                label = PositionLabel), 
            angle = 45, hjust = 0.5, size = 3)

# Interaktiven Plot mit ggplotly erstellen
interactive_plot3 <- ggplotly(p3)
interactive_plot3
```



### e interactiv boxplots: position on chr related
```{r}
# P4: PositionLabel interaktiv
p4 <- ggplot(beta_long_smooth, aes(x = Position, y = BetaValue, fill = Group)) +
  geom_boxplot(outlier.shape = NA, width = 2) +  
  geom_jitter(aes(color = Group, text = paste0(PositionLabel, "\n", SampleID)), 
              width = 0.2, height = 0, shape = 16) +  
  theme_minimal() +
  scale_fill_manual(values = c("guided" = "blue", "unguided" = "red")) +  
  labs(x = "Genomische Position auf Chr13", y = "Beta Value", fill = "Group") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Interaktive Plotly-Visualisierung mit Tooltips aktivieren
interactive_plot4 <- ggplotly(p4, tooltip = "text")
interactive_plot4

# Save the interactive plot as an HTML file
saveWidget(interactive_plot4, "interactive_boxplot_DMR2_smooth_pval_4.html")
```






# create boxplots (with functios for shiny app)
## 1- extract_cpgs_in_DMR function: it creates a table of cpgs in each DMR for Boxplots
```{r}
extract_cpgs_in_DMR <- function(DMRx, DMR_table, annotation_with_betas, pheno_data) {
  # Step 1: Check table availability
  if (missing(DMRx)) return("Error: 'DMRx' is missing.")

  # Step 2: Check if DMRx exists in DMR_table
  if (!(DMRx %in% DMR_table$DMR_Nr)) {
    return(paste("Error:", DMRx, "not found in DMR_table"))
  }

  # Step 3: Get start, end, chr
  DMR_row <- DMR_table[DMR_table$DMR_Nr == DMRx, ]
  chr <- DMR_row$chr
  start <- DMR_row$start
  end <- DMR_row$end

  # Step 4: Identify number of arrays/samples
  m <- nrow(pheno_data)
  # Get beta values from the last m columns
  beta_cols <- tail(colnames(annotation_with_betas), m)


  # step 5: Filter annotation_with_betas for CpGs in DMR region
  region_cpgs <- annotation_with_betas[
    annotation_with_betas$chr == chr & 
    annotation_with_betas$pos >= start & 
    annotation_with_betas$pos <= end,
    c("chr", "pos", beta_cols)
  ]

  if (nrow(region_cpgs) == 0) {
    return("No CpGs found in the specified DMR region.")
  }

  # Step 5: Return or plot boxplot-ready data
  return(region_cpgs)
}



# USING THE FUNCTION
#pheno_data <- pData(ratio_geno_Swan_NoSNP)
#annotated_with_betas
#dmrs_tbl

cpgs_DMR1 <- extract_cpgs_in_DMR("1",dmrs_df ,annotated_with_betas, pheno_data)
cpgs_DMR1
```

## 2- function: it creates a long format of the previous table
```{r}
library(tidyr)
library(dplyr)


reshape_to_long_beta <- function(region_cpgs, pheno_data) {
  # Step 1: Input checks
  if (missing(region_cpgs)) return("Error: 'region_cpgs' table is not available.")
  if (missing(pheno_data)) return("Error: 'pheno_data' table is not available.")
  
  # Convert region_cpgs to a data.frame (if it's not already)
  region_cpgs_df <- as.data.frame(region_cpgs)
  colnames(region_cpgs_df) = colnames(region_cpgs)
  pheno_df <- as.data.frame(pheno_data)


  # Step 2: Identify sample number
  m <- nrow(pheno_df)

  # Step 3: Identify beta value columns (last m columns)
  beta_cols <- tail(colnames(region_cpgs_df), m)

  # Step 4: Validate that beta values are numeric and in range [0, 1]
  beta_values <- region_cpgs_df[, beta_cols]
  if (!all(sapply(beta_values, is.numeric))) {
    return("Error: Not all beta columns are numeric.")
  }
  if (any(beta_values < 0 | beta_values > 1, na.rm = TRUE)) {
    return("Error: Some beta values are outside the range [0, 1].")
  }

  # Step 5: Ensure that 'chr' column exists in region_cpgs
  if (!"chr" %in% colnames(region_cpgs_df)) {
    return("Error: 'chr' column is missing in region_cpgs.")
  }

  # Step 6: Sort region_cpgs by position
  region_cpgs_df <- region_cpgs_df[order(region_cpgs_df$pos), ]

  # Step 7: Create long-format table
  beta_long <- region_cpgs_df %>%
    pivot_longer(
      cols = all_of(beta_cols),
      names_to = "SampleID",
      values_to = "BetaValue"
    ) %>%
    mutate(
      chr = rep(region_cpgs_df$chr, each = m) ,
      Position = rep(region_cpgs_df$pos, each = m),
      CpGName = rep(rownames(region_cpgs_df), each = m),
      Group = pheno_df$Sample_Group[match(gsub("^X", "", SampleID), rownames(pheno_df))]
    ) %>%
    ungroup() %>%
    select(chr, Position, CpGName, SampleID, Group, BetaValue) %>%
    mutate(PositionLabel = paste(CpGName, "\n", "pos=", Position))

  return(beta_long)
}




#try function:
long_DMR1 <- reshape_to_long_beta(cpgs_DMR1, pheno_data)
View(long_DMR1)
```

## 3- function of boxplots
```{r}
#library(ggplot2)
#library(plotly)
# Define the function
create_boxplot <- function(long_format_table, interactive = FALSE, use_positional_spacing = FALSE) {
  if (length(unique(long_format_table$chr)) != 1) {
    stop("Error: Not all CpGs are on one chromosome.")
  }

  # Correct x-axis variable name as string
  x_col <- if (use_positional_spacing) "Position" else "PositionLabel"
  
  # Define text aesthetics for tooltips
  long_format_table$text <- if (interactive) {
    if (use_positional_spacing) {
      paste0(long_format_table$SampleID, "\n", long_format_table$PositionLabel)
    } else {
      long_format_table$SampleID
    }
  } else {
    long_format_table$SampleID  # You still need a column, even if it's ignored
  }

  p <- ggplot(long_format_table, aes_string(x = x_col, y = "BetaValue", fill = "Group")) +
    geom_boxplot(
                 aes_string(group = "interaction(Position, Group)", color = "Group"),
                 outlier.shape = NA, color = "black", lwd = 0.3) +
    theme_minimal() +
    scale_fill_manual(values = c("guided" = "red", "unguided" = "blue")) +
    labs(
      x = if (use_positional_spacing) paste("Position on", unique(long_format_table$chr)) else paste("CPG + Position on", unique(long_format_table$chr)),
      y = "Beta Value",
      fill = "Group"
    ) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))

  if (interactive) {
  p <- suppressWarnings(
    p + geom_jitter(aes_string(color = "Group", text = "text"), width = 0.2, height = 0, shape = 16)
  )
  return(plotly::ggplotly(p, tooltip = "text"))
} else {
  p <- suppressWarnings(
    p + geom_jitter(aes_string(color = "Group"), width = 0.2, height = 0, shape = 16) 
  )
  return(p)
  }
}
create_boxplot(long_DMR1, interactive = TRUE, use_positional_spacing = TRUE)
```




