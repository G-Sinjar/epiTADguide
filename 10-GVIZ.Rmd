---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.


############ script ################
# libraries
```{r}
library(readxl)
library(dplyr)
library(GenomicRanges)
library(Gviz)
library(shiny)
library(bslib)
library(EnsDb.Hsapiens.v86)
library(GenomeInfoDb)
```

# defaults
```{r}
from <- 95433599
to <- 95579959  #95579759
genome <- "hg38"
chr <- "chr13"
```

# 1  GVIZ plot of the whole Iso A + B
## 1a -first 2 tracks (Ideogram, GenomicAxis)
```{r}
itrack <- IdeogramTrack(genome = genome, chromosome = chr)
gtrack <- GenomeAxisTrack()

#plotTracks(list(itrack,gtrack), showBandId = TRUE, cex.bands = 0.7,from = from, to = to)
```



## 1b -CpGs track
```{r}
# a- get the final table for all cpgs
cpgs <- read_excel("./Output/10-cpgs_for_Granges.xlsx",col_names = TRUE) #891492     23
#head(cpgs)

# b- convert to genomicRanges
gr_cpgs <- GRanges(seqnames = cpgs$chr,
              ranges = IRanges(start = cpgs$pos, end = cpgs$pos)) #,strand = cpgs_AB$strand)
mcols(gr_cpgs) <- cpgs[, 4:ncol(cpgs)]
#gr_cpgs


'# --- Define P-value Ranges and Corresponding Colors ---
legend_labels <- c("p≤0.001", "0.001<p≤0.01", "0.01<p≤0.05", "0.05<p≤0.1", "p>0.1")
p_value_ranges <- c(0, 0.001, 0.01, 0.05, 0.1, 1)
p_value_colors <- c(
  "#0b2b5b",  # Midnight Blue
  "#3f007d",  # Royal Purple
  "#084c61",  # Deep Teal
  "#6a5acd",  # Slate Blue
  "#9ebcda"   # Steel Blue
)

p_value_colors <- c(
  "#08306b",  # navy (very significant)
  "#2171b5",  # royal blue
  "#6baed6",  # sky blue
  "#bdd7e7",  # light blue
  "#deebf7"   # very light blue (not significant)
)

p_value_colors <- c(
  "#54278f",  # very significant (dark purple)
  "#2b8cbe",  # significant (blue)
  "#41ab5d",  # moderate (teal/green)
  "#fdb863",  # weakly significant (orange)
  "#d73027"   # not significant (red)
)

gr_cpgs$color_group <- p_value_colors[findInterval(gr_cpgs$pval, p_value_ranges)]

# -------- reorder the columns-------
# Get current column names
cols <- colnames(mcols(gr_cpgs))
# Find position to insert: before last 8 columns
insert_pos <- length(cols) - 9
# Remove #color_group# temporarily if already present
cols <- setdiff(cols, "color_group")
# New column order: insert #color_group# before last 8
new_order <- append(cols, "color_group", after = insert_pos)
# Reassign mcols in new order
mcols(gr_cpgs) <- mcols(gr_cpgs)[, new_order]
gr_cpgs
'

# Create the AnnotationTrack
sondentrack <- AnnotationTrack(gr_cpgs, 
                         chromosome = chr,
                         genome = genome,
                         name = "CpG Probes",
                         col = NA,
                         fill = gr_cpgs$color_group,
                         id = gr_cpgs$CpGs,
                         showFeatureId = FALSE)


# --- Create the plot ---
'plotTracks(list(itrack, gtrack, sondentrack),
           chromosome = chr,
           from = from,
           to = to,
           showBandId = TRUE,
           cex.bands = 0.7,
           stacking = "dense")'
```

## 1 legend label --> not sinvoll cause a full plot
```{r}
# Dynamisch berechnete Breite
plot_width <- to - from
box_width <- round(plot_width * 0.125)  # 10% der Plotlänge

legend_positions <- GRanges(seqnames = chr,
                            ranges = IRanges(start = from + seq(0, by = box_width * 1.5, length.out = length(legend_labels)),
                                             width = box_width),
                            feature = legend_labels)


legend_track <- AnnotationTrack(
  legend_positions,
  name = "Legende",
  genome = genome,
  chromosome = chr,
  feature = legend_labels,
  group = legend_labels,
  fill = p_value_colors,
  col = NA,
  showFeatureId = TRUE,
  cex.feature = 0.8              # Schriftgröße der Labels
  )

plotTracks(list(itrack, gtrack, legend_track, sondentrack),
           chromosome = chr,
           from = from,
           to = to,
           stacking = "dense",
           showBandId = TRUE,
           cex.bands = 0.7
           )

```



## 1G -CPG Islands track
```{r}
# GRanges of CpGIslands

#library(AnnotationHub) #dont work-> all on it are hg19

# download cpgislands from ucsc
url <- "http://hgdownload.cse.ucsc.edu/goldenpath/hg38/database/cpgIslandExt.txt.gz"
destfile <- "cpgIslandExt_hg38.txt.gz"

if (!file.exists(destfile)) {
  download.file(url, destfile)
  message("File downloaded.")
} else {
  message("cpgIslandExt_hg38.txt.gz File already exists. Skipping download.")
}
 #701 KB

# Read the file (it's gzipped, so use gzfile)
cpg_Islands <- read.table(gzfile(destfile), header = FALSE, sep = "\t", stringsAsFactors = FALSE)

colnames(cpg_Islands) <- c("bin", "chrom","chromStart","chromEnd","name","length","cpgNum","gcNum","perCpg","perGc", "obsExp")
View(cpg_Islands)

#Note: all start coordinates in our database are 0-based, not 1-based. 

# convert to GRanges
gr_cpgIslands <- GRanges(
  seqnames = cpg_Islands$chrom,   
  ranges = IRanges(
    start = cpg_Islands$chromStart + 1,  # Convert from 0-based to 1-based
    end = cpg_Islands$chromEnd))

mcols(gr_cpgIslands) <- cbind(
  feature = cpg_Islands$name,
  cpg_Islands[, 7:ncol(cpg_Islands)]
)
#gr_cpgIslands

# make AnnotationTrack
cpgIslandTrack <- AnnotationTrack(gr_cpgIslands,
  chromosome = chr,
  genome = genome,
  name = "CpG Islands",
  feature = mcols(gr_cpgIslands)$feature,
  fill = "darkgreen")

#plotTracks(cpgIslandTrack, from = from, to = to, groupAnnotation = "feature",just.group = "right")
```



## 1E -DMR track
```{r}
DMRs <- read_excel("./Output/8_DMRs_0.01_smooth_GRange.xlsx", col_names = TRUE)

head(DMRs)

# create a granges of the DMRs 
# Ensure DMRs is a data.frame (it can still be a tibble)
dmrs_gr <- makeGRangesFromDataFrame(
  df = DMRs,
  seqnames.field = "chr",
  start.field = "start",
  end.field = "end",
  strand.field = "strand",  # optional if strand column exists
  keep.extra.columns = TRUE
)
# Convert to numeric if needed
dmrs_gr$p.value <- as.numeric(as.character(dmrs_gr$p.value))

# Now build the track
DmrTrack <- AnnotationTrack(
  dmrs_gr,
  genome = genome,
  chromosome = chr,
  name = "DMRs",
  col = "orange",
  fill = "orange",
  feature = paste(dmrs_gr$DMR_ID, " P.val=", round(dmrs_gr$p.value, 5))
)


plotTracks(DmrTrack,from = from, to = to, groupAnnotation= "feature")
```


## 1  -Offtarget track
```{r}
# the granges of the offtarget is from script 11 
gr_offtargets

#pos on chr13 wo offtarget gibt
von = 113102059
zu =113104000

offtargetTrack <- AnnotationTrack(gr_offtargets, genome = genome, chromosome = chr,
                                  name = "potential Off-targets\n[-70,+70]", feature = gr_offtargets$ID, col= NA,fill = "red")

plotTracks(offtargetTrack, chromosome = "chr13", from = von, to= zu, groupAnnotation ="feature", fontcolor.group= "black")
```

## 1c -beta values pointplot track
```{r}
# the strand has to be unique here
#data = must be a data matrix
#from the previus step we have gr_cpgs

# Extract beta values from metadata columns (as DataFrame)
beta_values <- as.data.frame(mcols(gr_cpgs)[, tail(seq_along(mcols(gr_cpgs)), 8)])


betaTrack <- DataTrack(gr_cpgs, chromosome = chr, genome = genome,
                    name = "Beta values",
                    data = beta_values)
 
#plotTracks(betaTrack, groups = rep(c("unguided", "guided"), each = 4),type = c("a", "p"), from = from , to = to) 
# or with aggregate aggregateGroups = TRUE, aggregation = "mean"
rep(c("unguided", "guided"), each = 4) -> c("unguided", "unguided", "unguided", "unguided", "guided", "guided", "guided", "guided")
rep(c("unguided", "guided"), times = 4) -> c("unguided", "guided", "unguided", "guided", "unguided", "guided", "unguided", "guided")
```






## 1H -Gene track
### 1H.1 from UCSC -> no gene names -> gave up on this
```{r}
# you can get a TxDb object from any GFF  file easily 
#BiocManager::install("TxDb.Hsapiens.UCSC.hg38.knownGene")
library(TxDb.Hsapiens.UCSC.hg38.knownGene) #--> anstatt knownGene -> refGene

TxDb <-  TxDb.Hsapiens.UCSC.hg38.knownGene
#TxDb
#unique(feature(GeneTrack))

# ploting# TxDbploting
ensTransTrack <- GeneRegionTrack(TxDb, chromosome = chr, name = "gene/transcript", transcriptAnnotation = "gene", just.group = "above")

plotTracks(ensTransTrack, from = from, to =to )



## try TxDb.Hsapiens.UCSC.hg38.refGene
#BiocManager::install("TxDb.Hsapiens.UCSC.hg38.refGene")
library(TxDb.Hsapiens.UCSC.hg38.refGene)

txDb_refGene
head(genes(txDb_refGene)) # --> just gene ID


# Plot the track
plotTracks(reGenTrack, chromosome = chr)
plotTracks(reGenTrack, from= from , to= to)
```


### 1H.2 from ENsDb: 
```{r}
#BiocManager::install("EnsDb.Hsapiens.v86")  # Ensembl 86 (GRCh38)
#cant pack gene, transcript and exon infos in one granges and plot gene cause it is will be replicated according to the numner of transcripts/ exons bzw.rows

# Get EnsDb
library(EnsDb.Hsapiens.v86)
edb <- EnsDb.Hsapiens.v86
options(ucscChromosomeNames = TRUE)

#To extract specific data, such as transcript or gene information, from an EnsDb object, you can use functions like transcripts(), genes(), and exons().
######################### Get gene ranges
tx_gr <- genes(edb)
#length(tx_gr) # 63970
head(tx_gr)

# Filter to standard chromosomes only????
tx_gr_filtered <- keepSeqlevels(tx_gr, standardChromosomes(tx_gr), pruning.mode = "coarse")
#length(tx_gr_filtered) #58650
#tx_gr_filtered
seqlevelsStyle(tx_gr_filtered) <- "UCSC"
#tx_gr_filtered


#h <- GeneRegionTrack(tx_gr_filtered, chromosome = chr, name = "gene/transcript", transcriptAnnotation = "gene_name" ) 
#plotTracks(h, from = from, to = to) # but i dont get the shön shape only boxes
geneTrack <- AnnotationTrack(tx_gr_filtered,
                          chromosome = chr,
                          name = "Gene Ens",
                          id= tx_gr_filtered$gene_name)
plotTracks(geneTrack, from = from, to = to, featureAnnotation= "id", col = "darkblue")
```



### 1H.4 Get transcript ranges (as GRanges) --> not nice to see
```{r}
transcript_tx_gr <- transcripts(edb)
length(transcript_tx_gr) #  216741
head(seqlevels(transcript_tx_gr))


# Filter to standard chromosomes only
transcript_tx_gr_filt <- keepSeqlevels(transcript_tx_gr, standardChromosomes(transcript_tx_gr), pruning.mode = "coarse")
length(transcript_tx_gr_filt)# 198739 -->91.69423%
transcript_tx_gr_filt

#try with geneRegioTrack ---> didnt work: Fehler: kann Vektor der Größe 294.3 GB nicht allozieren
transTrack <- AnnotationTrack(transcript_tx_gr_filt,
                          chromosome = chr,
                          name = "Gene Ens",
                          id= transcript_tx_gr_filt$tx_id)

#plotTracks(transTrack, from = from, to = to, groupAnnotation= "id", just.group= "above")
```





## 1g -SUBTADs Track CAKI2
```{r}
# create TAD Granges
tissue <- "CAKI2"
chr <- "chr13"
binsize <- 25
from <- 95433599
to <- 95579759

SUBTADs_filepath <- sprintf("../PythonProject/TADs_CAKI2/3_TADs_as_txt_and_Excel/%s_%s_%skb_SubTADs_noDuplicates.txt", tissue, chr, binsize)
SUBTADs <- read.delim(SUBTADs_filepath, header = TRUE)
#View(SUBTADs) #80


# convert to Granges 
gr_SUBTADs <- GRanges(seqnames = chr,
              ranges = IRanges(start = SUBTADs$StartPos, end = SUBTADs$EndPos))
gr_SUBTADs

### plot tad track
SUBTadTrack <- AnnotationTrack(gr_SUBTADs, genome = genome, 
                            name = paste0("SUBTADs\nCaki2\n",binsize, "kb"), col= "black", fill="pink")

plotTracks(SUBTadTrack, from = from, to = to) # try to change shape 
```


## 1F -TAD Track CAKI2
```{r}
# create TAD Granges
tissue <- "CAKI2"
binsize <- 25 # or 10


TADs <- read_excel(sprintf("../PythonProject/TADs_CAKI2/3_TADs_as_txt_and_Excel/%s_%s_%skb_TADs.xlsx",tissue, chr, binsize), skip =2)

# Convert columns to numeric
TADs <- TADs %>%
  mutate(across(c(StartPos, EndPos, TadLength), as.numeric))


# convert Tad_df to Granges 
gr_TADs <- GRanges(seqnames = chr,
              ranges = IRanges(start = TADs$StartPos, end = TADs$EndPos))
mcols(gr_TADs) <- TADs[, 1]
#gr_TADs

### plot tad track
TadTrack <- AnnotationTrack(gr_TADs , genome = genome, 
                            name = paste0("TADs\nCaki2\n",binsize, "kb"), 
                            feature = gr_TADs$TadNr,  
                            col = "black", fill= "purple")

#plotTracks(TadTrack, featureAnnotation = "feature", fontcolor.feature = "darkblue",from = from, to = to) # try to change shape 
```

## 1g -TAD Track SKIN -> no files of skin in this dir
### 10kb create TAD Granges
```{r}
tissue2 <- "skin"
chr <- "chr13"
binsize <- 25
from <- 95433599
to <- 95579759

#SUBTADs_filepath2 <- sprintf("../PythonProject/TADs_CAKI2/3_TADs_as_txt_and_Excel/%s_%s_%skb_SubTADs_noDuplicates.txt", tissue2, chr, binsize)
#SUBTADs2 <- read.delim(SUBTADs_filepath, header = TRUE)
#View(SUBTADs2)
# Convert columns to numeric
tad_skin_10kb <- tad_skin_10kb %>%
  mutate(across(c(StartPos, EndPos, TadLength), as.numeric))


# convert Tad_df to Granges 
chr_TAD <- "chr13"
gr_tad_skin_10kb <- GRanges(seqnames = chr_TAD,
              ranges = IRanges(start = tad_skin_10kb$StartPos, end = tad_skin_10kb$EndPos))
mcols(gr_tad_skin_10kb) <- tad_skin_10kb[, 1]
gr_tad_skin_10kb


### plot tad track
TadTrack_skin_10kb <- AnnotationTrack(gr_tad_skin_10kb, 
                            name = paste0("TADs-Skin fibroblast-",bin_size_skin10), 
                            feature = gr_tad_skin_10kb$TadNr,  
                            col = "black")

plotTracks(TadTrack_skin_10kb,groupAnnotation = "feature", from = from, to = to)
```

### 25kb create TAD Granges
```{r}
bin_size_skin25 <- 25000
tad_skin_25kb <- read_excel("C:/Users/ghaza/Documents/ghazal/Bioinformatik_Fächer/Masterarbeit_Project/Scripts/PythonProject/TADs_skin/3_TADs_as_txt_and_Excel/Skin_fibro_chr13_25000bp_TADs.xlsx", skip =2)

# Convert columns to numeric
tad_skin_25kb <- tad_skin_25kb %>%
  mutate(across(c(StartPos, EndPos, TadLength), as.numeric))


# convert Tad_df to Granges 
chr_TAD <- "chr13"
gr_tad_skin_25kb  <- GRanges(seqnames = chr_TAD,
              ranges = IRanges(start = tad_skin_25kb$StartPos, end = tad_skin_25kb$EndPos))
mcols(gr_tad_skin_25kb) <- tad_skin_25kb[, 1]
gr_tad_skin_25kb 


### plot tad track
TadTrack_skin_25kb <- AnnotationTrack(gr_tad_skin_25kb , 
                            name = paste0("TADs-Skin fibroblast-",bin_size_25), 
                            feature = gr_tad_skin_25kb$TadNr,  
                            col = "black")

plotTracks(TadTrack_skin_25kb,groupAnnotation = "feature", from = from, to = to)
```


## 1 - function to Plot all tracks together + save
```{r}
# Suppress labels on atrack
#displayPars(atrack) <- list(groupAnnotation = "none",showFeatureId = FALSE)
# Set groupAnnotation = "feature" ONLY on the track(s) where you want to see feature labels

plotGvizTracks <- function(from, to){
    displayPars(DmrTrack) <- list(groupAnnotation = "feature")  
    displayPars(cpgIslandTrack) <- list(groupAnnotation = "feature") 
    displayPars(sondentrack) <- list(stacking= "dense",showFeatureId = FALSE) 
    displayPars(geneTrack) <- list(featureAnnotation= "id",fontcolor.feature = "darkblue") 
    displayPars(offtargetTrack) <- list(groupAnnotation ="feature", fontcolor.group= "black") 
    displayPars(geneTrack) <- list(  featureAnnotation = "id", fontcolor.feature = "black", stacking = "full", cex = 0.7)




    plotTracks(list(itrack, gtrack,sondentrack,cpgIslandTrack, DmrTrack, offtargetTrack,betaTrack,geneTrack,SUBTadTrack,TadTrack),#ensTransTrack #
    from = from, to = to,
    showBandId = TRUE, cex.bands = 0.7,
    groups = rep(c("unguided", "guided"), each = 4),type = c("a", "p"), #for beta track
    transcriptAnnotation = "transcript",
    cex.group = 0.9,
    cex.legend = 0.9,
    cex.title = 0.75 , # size of the track names
    col.title = "black"
    )
}
```

# getting chromosome length
```{r}
#BiocManager::install("BSgenome.Hsapiens.UCSC.hg38")
#BiocManager::install("GenomeInfoDb")

library(BSgenome.Hsapiens.UCSC.hg38)
library(GenomeInfoDb)

# Load the hg38 genome
hg38 <- BSgenome.Hsapiens.UCSC.hg38

# Get chromosome lengths
chr_lengths <- seqlengths(hg38)

# Print as data frame
chr_size_df <- data.frame(
  Chromosome = names(chr_lengths),
  Length = as.numeric(chr_lengths)
)

# View top rows
View(chr_size_df)
```


# shiny app:
```{r}
'dmr_ranges <- list(
  CLDN10 = c(95433599, 95579759),
  DMR1 = c(95552350,95553081),
  DMR16 = c(22735536,  22737536),
  TAD28 = c(94625000, 97850000), 
  SubTAD65 = c(94550000, 95875000),
  offtarget_g2 = c(113102059, 113104059),
  offtarget_g5 = c(110956200, 110958900)
)'

chr13_length <- 114364328

ui <- page_navbar(
  title = "EPIC Array Pipeline",
  theme = bs_theme(version = 5, bootswatch = "flatly"),
  
  nav_panel("Final Plot",
    layout_sidebar(
      sidebar = sidebar(
        width = 300,
        
        selectInput("region_type", "Choose Region Type:",
            choices = c("DMRs", "Off-targets"), selected ="DMRs"),
        uiOutput("region_selector"),
        numericInput("from", "From:", 
                    value = dmr_ranges[["DMR1"]][1], 
                    min = 1, max = chr13_length),
        numericInput("to", "To:", 
                    value = dmr_ranges[["DMR1"]][2], 
                    min = 1, max = chr13_length),
        tags$div(style = "font-size: 15px; color: #555;",
                  helpText("Note: The boundaries of TADs and sub-TADs are approximate and depend on the resolution of the TAD-calling algorithm. The resolution                   used is indicated in the name of the TAD and sub-TAD tracks.")
        ),
        
        actionButton("update", "Submit", class = "btn-primary"),
        div(
          actionButton("zoom_in", "🔍 Zoom In", class = "btn btn-success btn-sm"),
          actionButton("zoom_out", "🔎 Zoom Out", class = "btn btn-warning btn-sm"),
          br(), br(),
          actionButton("go_left", "⬅️ Go Left", class = "btn btn-secondary btn-sm"),
          actionButton("go_right", "➡️ Go Right", class = "btn btn-secondary btn-sm")
        ),
        
        # Compact Legend directly below buttons
        tags$div(
          style = "font-size: 12px; margin-top: 10px;",
          tags$strong("CpG track Legend (P-Values of CpGs):"),
          br(),
          lapply(seq_along(p_value_colors), function(i) {
            div(style = "margin-bottom: 4px; display: flex; align-items: center;",
                div(style = paste0("width:14px;height:14px;background-color:", p_value_colors[i],
                                   ";margin-right:6px;border:1px solid black;flex-shrink:0;")),
                span(style = "flex-grow:1;", legend_labels[i])
            )
          })
        ),
        
        br(), downloadButton("downloadPlot", "Save Plot as PDF")
      ),
      plotOutput("gvizPlot", height = "1000px")
    )
  )
)


server <- function(input, output, session) {
  pendingRange <- reactiveVal(c(NA, NA))
  # Initial selected range based on default DMR
  selectedRange <- reactiveVal(c(start(dmrs_gr[dmrs_gr$DMR_ID == "CLDN10.DMR"]),
                                 end(dmrs_gr[dmrs_gr$DMR_ID == "CLDN10.DMR"])))

  # Reactive UI for region ID dropdown
  output$region_selector <- renderUI({
    if (input$region_type == "DMRs") {
      selectInput("region_id", "Choose DMR:", choices = dmrs_gr$DMR_ID)
    } else {
      selectizeInput("region_id", "Choose Off-target:", 
                     choices = gr_offtargets$ID, 
                     options = list(create = TRUE, placeholder = "Type or select Off-target ID"))
    }
  })

  # Update from/to based on selected region
  observeEvent(input$region_id, {
  req(input$region_type, input$region_id)
  
  if (input$region_type == "DMRs") {
    sel <- dmrs_gr[dmrs_gr$DMR_ID == input$region_id]
  } else {
    sel <- gr_offtargets[gr_offtargets$ID == input$region_id]
  }

  if (length(sel) == 1) {
    pad <- 2000
    new_from <- max(1, start(sel) - pad)
    new_to <- min(chr13_length, end(sel) + pad)

    # Save these values for later, but don't update UI yet
    pendingRange(c(new_from, new_to))
  } else {
  showNotification("No matching region found for selected ID.", type = "warning")
  }
})



  observeEvent(input$update, {
  range_vals <- pendingRange()
  if (!any(is.na(range_vals))) {
    if (range_vals[1] >= range_vals[2]) {
      showNotification("Invalid region: 'From' must be less than 'To'", type = "error")
      return()
    }
    updateNumericInput(session, "from", value = range_vals[1])
    updateNumericInput(session, "to", value = range_vals[2])
    selectedRange(range_vals)
    pendingRange(c(NA, NA))  # Reset pending state
  } else {
    if (input$from >= input$to) {
      showNotification("Invalid range: 'From' must be less than 'To'", type = "error")
      return()
    }
    selectedRange(c(input$from, input$to))
  }
})


  observeEvent(input$region_type, {
  pendingRange(c(NA, NA))
  showNotification("Region type changed. Please select a new region and click Submit.", type = "message", duration = 3)
})


  # Plot rendering
  output$gvizPlot <- renderPlot({
  req(selectedRange())
  from <- selectedRange()[1]
  to <- selectedRange()[2]

  # Validate: make sure range is legal
  validate(
    need(from < to, "'From' must be less than 'To'. Please correct the range and click Submit.")
  )

  plotGvizTracks(from, to)
})


  # Plot download
  output$downloadPlot <- downloadHandler(
    filename = function() {
      paste0("GvizPlot_chr13_", input$from, "_", input$to, ".pdf")
    },
    content = function(file) {
      pdf(file, width = 25, height = 15)
      plotGvizTracks(input$from, input$to)
      dev.off()
    }
  )

  # Zoom controls
  zoomvalue <- 6000

  observeEvent(input$zoom_in, {
    new_from <- max(1, input$from + zoomvalue)
    new_to <- min(chr13_length, input$to - zoomvalue)
    updateNumericInput(session, "from", value = new_from)
    updateNumericInput(session, "to", value = new_to)
    selectedRange(c(new_from, new_to))
  })

  observeEvent(input$zoom_out, {
    new_from <- input$from - zoomvalue
    new_to <- input$to + zoomvalue
    if (new_from < new_to) {
      updateNumericInput(session, "from", value = new_from)
      updateNumericInput(session, "to", value = new_to)
      selectedRange(c(new_from, new_to))
    }
  })

  observeEvent(input$go_left, {
    new_from <- max(1, input$from - zoomvalue)
    new_to <- max(1, input$to - zoomvalue)
    updateNumericInput(session, "from", value = new_from)
    updateNumericInput(session, "to", value = new_to)
    selectedRange(c(new_from, new_to))
  })

  observeEvent(input$go_right, {
    new_from <- min(chr13_length, input$from + zoomvalue)
    new_to <- min(chr13_length, input$to + zoomvalue)
    updateNumericInput(session, "from", value = new_from)
    updateNumericInput(session, "to", value = new_to)
    selectedRange(c(new_from, new_to))
  })
}

shinyApp(ui, server)
```

