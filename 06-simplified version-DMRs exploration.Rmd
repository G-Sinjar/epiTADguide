---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.


# library
```{r}
library(minfi)
library(dplyr)
```

# Preparing for bumhunter
```{r}
ratio_geno_Swan_NoSNP <- readRDS("./intermediate_data/filtered_GRset_SWAN_SNP_removed_SexChr_kept_20250605.rds")

# 1. Define the phenotype of interest
pheno <- pData(ratio_geno_Swan_NoSNP)$Sample_Group
# 2. Change the reference level to "unguided" so the value is minus on chr13 target
if (!is.factor(pheno)) {
  pheno_factor <- factor(pheno)
}
pheno_factor <- relevel(pheno_factor, ref = "unguided")


# 3. designMatrix
designMatrix <- model.matrix(~ pheno_factor)
```


# DMRs cutoff 0,15  B=100  smooth= FALSE
```{r}
library(doParallel)
registerDoParallel(cores = 4)

dmrs <- bumphunter(ratio_geno_Swan_0.05_NoSNP, design = designMatrix, cutoff = 0.15, B=100, type="Beta", maxGap = 500)

#dim(dmrs2$table) #1067   15
View(dmrs2$table)
```


# DMRs with cutoff=0.15,   B=100   smooth = TRUE
```{r}
library(doParallel)
registerDoParallel(cores = 6)
dmrs <- bumphunter(ratio_geno_Swan_NoSNP, design = designMatrix, cutoff = 0.15, B=100, type="Beta", smooth = TRUE) 
View(dmrs$table) # info u get pvalue only of B>0
#0,2 B=0 --> 1dmr chr6
#0,15 B=0 --> 16 DMR
#0,15 B=100 --> 16 DMR
```

# 1. bumphunter function
```{r}
run_bumphunter_dmrs <- function(rgSet, cutoff = 0.15, B = 0) {
  # Extract phenotype data
  pd <- tryCatch({
    pData(rgSet)
  }, error = function(e) {
    stop(paste("Error extracting phenotype data:", e$message))
  })
  
  if (!"Sample_Group" %in% colnames(pd)) {
    stop("Column 'Sample_Group' not found in phenotype data.")
  }
  
  # Prepare phenotype factor
  sample_group <- pd$Sample_Group
  if (!is.factor(sample_group)) sample_group <- factor(sample_group)
  sample_group <- relevel(sample_group, ref = "unguided")
  
  # Create design matrix
  designMatrix <- model.matrix(~ sample_group)
  
  # Set up parallel backend
  if (!requireNamespace("doParallel", quietly = TRUE)) {
    stop("Package 'doParallel' is required for parallel execution.")
  }
  doParallel::registerDoParallel(cores = 6)
  
  # Run bumphunter with error handling
  dmrs <- tryCatch({
    bumphunter(
      rgSet,
      design = designMatrix,
      coef = 2,
      cutoff = cutoff,
      B = B,
      type = "Beta",
      smooth = TRUE
    )
  }, error = function(e) {
    warning(paste("Error during bumphunter execution:", e$message))
    return(NULL)
  })
  
  # If bumphunter failed
  if (is.null(dmrs)) {
    return(NULL)
  }
  
  # Convert to data frame
  dmrs_tbl <- as.data.frame(dmrs$table)
  rownames(dmrs_tbl) <- NULL
  
  return(list(
    DMR_table = dmrs_tbl,
    pd = pd
  ))
}


# test the finction
dmrs_a <- run_bumphunter_dmrs(rgSet = ratio_geno_Swan_NoSNP,cutoff = c(-0.15, 0.15), B = 0)
pheno <- dmrs_a$pd
dmrtable <- dmrs_a$DMR_table
```


# 2. prepare_dmrs_granges()
```{r}

library(GenomicRanges)
library(dplyr)
library(tibble)

prepare_dmrs_granges <- function(dmrs_df) {
  # Convert to GRanges
  gr <- makeGRangesFromDataFrame(
    df = dmrs_df,
    seqnames.field = "chr",
    start.field = "start",
    end.field = "end",
    keep.extra.columns = TRUE
  )

  # Safely rename metadata columns if they exist
  if ("value" %in% names(mcols(gr))) {
    names(mcols(gr))[names(mcols(gr)) == "value"] <- "mean.methy.difference"
  }
  if ("L" %in% names(mcols(gr))) {
    names(mcols(gr))[names(mcols(gr)) == "L"] <- "CpGs.inDMR"
  }
  if ("clusterL" %in% names(mcols(gr))) {
    names(mcols(gr))[names(mcols(gr)) == "clusterL"] <- "CpGs.inCluster"
  }

  # Add width column
  mcols(gr)$width <- width(gr)

  # Sort by CpGs.inDMR if present
  if ("CpGs.inDMR" %in% names(mcols(gr))) {
    gr <- gr[order(gr$CpGs.inDMR, decreasing = TRUE)]
  }

  # Reorder metadata columns if they exist
  all_cols <- names(mcols(gr))
  desired_cols <- c("width", "mean.methy.difference", "CpGs.inDMR", "p.value", "cluster", "CpGs.inCluster")
  cols_to_select <- desired_cols[desired_cols %in% all_cols]

  reordered_mcols <- mcols(gr) %>%
    as_tibble() %>%
    select(any_of(cols_to_select), everything())

  # Round numeric (non-integer) columns to 5 digits
  is_roundable <- sapply(reordered_mcols, function(x) {
    is.numeric(x) && !all(x == floor(x), na.rm = TRUE)  # True for decimals, not pure integers
  })

  reordered_mcols[is_roundable] <- lapply(reordered_mcols[is_roundable], function(x) round(x, 5))

  # Convert back to DataFrame and set as mcols
  mcols(gr) <- as(reordered_mcols, "DataFrame")

  return(gr)
}



#Test function:
library(readxl)
dmrs <- read_excel("./Output/8-DMRs_0.01_smooth.xlsx")
dmrs 

D <- prepare_dmrs_granges(dmrs_df = dmrs)
#D
```


# Annotate DMRs
```{r}
annotate_dmrs_with_genes <- function(GR_Dmrs, tx_gr_filtered) {
  # -------------------- STEP 1: FIRST GENE NAME --------------------
  hits_first <- findOverlaps(GR_Dmrs, tx_gr_filtered, ignore.strand = TRUE, select = "first")
  first_gene_names <- tx_gr_filtered$gene_name[hits_first]
  mcols(GR_Dmrs)$overlapped_gene_name <- first_gene_names
  
  # -------------------- STEP 2: CONCATENATED GENE NAMES --------------------
  hits_all <- findOverlaps(GR_Dmrs, tx_gr_filtered, ignore.strand = TRUE)
  overlapping_gene_names_list <- split(tx_gr_filtered$gene_name[subjectHits(hits_all)],
                                       queryHits(hits_all))
  
  concatenated_gene_names_vector <- sapply(overlapping_gene_names_list, paste, collapse = ";")
  all_concat_names <- rep(NA_character_, length(GR_Dmrs))
  all_concat_names[as.integer(names(concatenated_gene_names_vector))] <- concatenated_gene_names_vector
  mcols(GR_Dmrs)$concatenated_gene_names <- all_concat_names
  
  # -------------------- STEP 3: UNIQUE DMR IDs --------------------
  hits_df <- data.frame(
    DMR_idx = queryHits(hits_all),
    Gene_idx = subjectHits(hits_all)
  )
  
  gene_info_df <- tx_gr_filtered[subjectHits(hits_all)] %>%
    as.data.frame() %>%
    select(gene_name)
  
  hits_df <- cbind(hits_df, gene_info_df)
  
  dmr_info <- as.data.frame(GR_Dmrs) %>%
    select(seqnames) %>%
    mutate(DMR_idx = seq_len(length(GR_Dmrs)))
  
  dmr_gene_df <- left_join(dmr_info, hits_df, by = "DMR_idx") %>%
    mutate(gene_name = ifelse(is.na(gene_name), "NoGene", gene_name)) %>%
    group_by(DMR_idx) %>%
    summarize(
      Chromosome = first(seqnames),
      Gene_names = paste(unique(gene_name), collapse = ";"),
      .groups = "drop"
    )
  
  dmr_gene_df$Base_ID <- paste0(dmr_gene_df$Gene_names, ".DMR")
  
  # Ensure uniqueness by appending suffixes
  id_counts <- table(dmr_gene_df$Base_ID)
  suffixes <- rep("", nrow(dmr_gene_df))
  
  for (id in unique(dmr_gene_df$Base_ID)) {
    matches <- which(dmr_gene_df$Base_ID == id)
    if (length(matches) > 1) {
      suffixes[matches] <- paste0("-", seq_along(matches))
    }
  }
  
  dmr_gene_df$DMR_ID <- paste0(dmr_gene_df$Base_ID, suffixes)
  
  # Add DMR_ID to GRanges object
  DMR_IDs <- rep(NA_character_, length(GR_Dmrs))
  DMR_IDs[dmr_gene_df$DMR_idx] <- dmr_gene_df$DMR_ID
  mcols(GR_Dmrs)$DMR_ID <- DMR_IDs
  
  return(GR_Dmrs)
}


#Test function
D_annotated <- annotate_dmrs_with_genes(D, tx_gr_filtered)
D_annotated
```


# save/ get DMR table
```{r}
GR_Dmrs_df <- as.data.frame(GR_Dmrs)
#writexl::write_xlsx(GR_Dmrs_df, "./Output/8_DMRs_0.01_smooth_GRange.xlsx")

# get dmrs_smooth from excel
library(readxl)
dmrs_smooth <- read_excel("./Output/8-DMRs_0.01_smooth.xlsx")
head(dmrs_smooth) 
```

# create boxplots for DMRs (with smoothing) ########################
## 1 bind to cpps DMR1 smooth
```{r}
# Binding to annotation table to get cpgs infos:
cpgs_DMR1 <- annotation_df[annotation_df$chr == "chr13" & 
                       annotation_df$pos >= dmrs_smooth$start[1]& 
                       annotation_df$pos <= dmrs_smooth$end[1], ]
View(cpgs_DMR1)
```
## 2 get dmp table
```{r}
View(dmp)

# get dmp_NoShrink from excel
library(readxl)
dmp <- read_excel("./Output/7-DMPs_NoShrink_0,01.xlsx")
View(dmp)
```

## 3 Add columns (pval, beta and M differnces) to the cpgs_DMR1 
```{r}
# 1. get-pvalue from dmp table
cpgs_DMR1_pval <- dmp[rownames(cpgs_DMR1), ]
View(cpgs_DMR1_pval)

identical(rownames(cpgs_DMR1_pval), rownames(cpgs_DMR1)) # true

# 2. Add the extracted values as new columns in cpgs_DMR1
cpgs_DMR1$P.Value <- cpgs_DMR1_pval$pval
cpgs_DMR1$Beta_Difference <- cpgs_DMR1_pval$beta_difference
cpgs_DMR1$M_Difference <- cpgs_DMR1_pval$M_difference

View(cpgs_DMR1)
```
## 4  DMR1 boxplot
### a-create a table for boxplot of cpgs in one DMR1  
```{r}
# create the box plot table
library(dplyr)

cpgs_DMR1_for_boxplot <- cpgs_DMR1 %>% select(chr, pos, strand, P.Value, 35:42)

View(cpgs_DMR1_for_boxplot)

# save and send to cornelia
writexl::write_xlsx(cpgs_DMR1_for_boxplot, "./Output/cpgs_in_DMR1_forBoxplots.xlsx")
```


### b-  creating a long format table ready for boxplots of all cpgs in one DMR
```{r}
library(tidyr)
beta_long_smooth <- cpgs_DMR1_for_boxplot %>%
  rowwise() %>%
  pivot_longer(
    cols = 5:12,  # Selecting beta value columns
    names_to = "SampleID",
    values_to = "BetaValue"
  ) %>%
  mutate(
    Group = pheno[match(SampleID, colnames(cpgs_DMR1_for_boxplot)[5:12])],  # Match sample to Group
    Position = rep(cpgs_DMR1_for_boxplot$pos, each = length(5:12)),
    CpGName = rownames(cpgs_DMR1_for_boxplot)[rep(1:nrow(cpgs_DMR1_for_boxplot), each = length(5:12))],
  ) %>%
  ungroup() %>%
  select(Position, SampleID, BetaValue, Group, CpGName)  # Select desired columns

# 0rder the cpgs according to pos
beta_long_smooth <- beta_long_smooth[order(beta_long_smooth$Position, decreasing = FALSE), ]

 
# add this column from dmps
beta_long_smooth <- beta_long_smooth %>%
  mutate(P.Value = cpgs_DMR1_for_boxplot$P.Value[match(CpGName, rownames(cpgs_DMR1_for_boxplot))])

beta_long_smooth <- beta_long_smooth %>%
  mutate(PositionLabel = paste(CpGName, "\n", "pval =", round(P.Value, 5)))

View(beta_long_smooth)

# save and send to cornelia
writexl::write_xlsx(beta_long_smooth, "./Output/longformat_cpgs_in_DMR1_forBoxplots.xlsx")
```

### c basic interactive Boxplots of cpgs in one DMR
```{r}
p2 <- ggplot(long_DMR1, aes(x = factor(PositionLabel), y = BetaValue, fill = Group)) +
  geom_boxplot(outlier.shape = NA) +  # Remove default outlier points
  geom_jitter(aes(color = Group, text = SampleID), width = 0.2, height = 0, shape = 16) +  # Add outlier points manually
  theme_minimal() +
  scale_fill_manual(values = c("guided" = "blue", "unguided" = "red")) +  # Custom colors
  labs(x = "CPG + Position on Chr13", y = "Beta Value", fill = "Group") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p2
interactive_plot2 <- ggplotly(p2)
interactive_plot2
```

### d interactiv boxplots: position on chr related  # PositionLabel oben
```{r}
# P3: distanz zwischen Boxes ist abhängig von echte Distanz 
p3 <- ggplot(beta_long_smooth, aes(x = Position, y = BetaValue, fill = Group)) +
  geom_boxplot(outlier.shape = NA, width = 2) +  
  geom_jitter(aes(color = Group), width = 0.2, height = 0, shape = 16) +  
  theme_minimal() +
  scale_fill_manual(values = c("guided" = "blue", "unguided" = "red")) +  
  labs(x = "Genomische Position auf Chr13", y = "Beta Value", fill = "Group") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  
  # PositionLabel über den Boxplots anzeigen
  geom_text(data = beta_long_smooth, 
            aes(x = Position, y = max(beta_long_smooth$BetaValue) + 0.05, 
                label = PositionLabel), 
            angle = 45, hjust = 0.5, size = 3)

# Interaktiven Plot mit ggplotly erstellen
interactive_plot3 <- ggplotly(p3)
interactive_plot3
```



### e interactiv boxplots: position on chr related
```{r}
# P4: PositionLabel interaktiv
p4 <- ggplot(beta_long_smooth, aes(x = Position, y = BetaValue, fill = Group)) +
  geom_boxplot(outlier.shape = NA, width = 2) +  
  geom_jitter(aes(color = Group, text = paste0(PositionLabel, "\n", SampleID)), 
              width = 0.2, height = 0, shape = 16) +  
  theme_minimal() +
  scale_fill_manual(values = c("guided" = "blue", "unguided" = "red")) +  
  labs(x = "Genomische Position auf Chr13", y = "Beta Value", fill = "Group") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Interaktive Plotly-Visualisierung mit Tooltips aktivieren
interactive_plot4 <- ggplotly(p4, tooltip = "text")
interactive_plot4

# Save the interactive plot as an HTML file
saveWidget(interactive_plot4, "interactive_boxplot_DMR2_smooth_pval_4.html")
```



















# create boxplots (with functios for shiny app)
## 1- extract_cpgs_in_DMR function: it creates a table of cpgs in each DMR for Boxplots
```{r}
extract_cpgs_in_DMR <- function(DMRx, DMR_table, annotated_table, pheno) {
  # Step 1: Check input
  if (missing(DMRx)) return("Error: 'DMRx' is missing.")
  if (is.null(annotated_table)) {
    return("Error: annotated_table is missing.")
  }
  if (is.null(pheno)) {
    return("Error: phenotype data (pheno) is missing.")
  }

  # Step 2: Check if DMRx exists
  if (!(DMRx %in% DMR_table$DMR_ID)) {
    return(paste("Error:", DMRx, "not found in DMR table"))
  }

  # Step 3: Extract DMR region info
  DMR_row <- DMR_table[DMR_table$DMR_ID == DMRx, ]
  chr <- DMR_row$chr
  start <- DMR_row$start
  end <- DMR_row$end

  # Step 4: Get beta columns using pheno
  m <- length(pheno)
  beta_cols <- tail(colnames(annotated_table), m)

  # Step 5: Subset annotation table for CpGs in the DMR
  region_cpgs <- annotated_table[
    annotated_table$chr == chr &
      annotated_table$pos >= start &
      annotated_table$pos <= end,
    c("chr", "pos", beta_cols)
  ]

  if (nrow(region_cpgs) == 0) {
    return("No CpGs found in the specified DMR region.")
  }

  return(region_cpgs)
}



# USING THE FUNCTION

#annotation_results <- readRDS("./modules/intermediate_data/annotated_object_20250623.rds")
#annotated_tbl <- annotation_results$annotated_table 

#dmr_results <- readRDS("./modules/intermediate_data/DMRs_cutoff_neg0.15_to_0.15_B0_2025-06-23.rds")
#dmr_tbl <-  dmr_results$dmr_table

#pheno <- dmr_results$pheno_data

#DMRx <- "CLDN10.DMR"

cpgs_DMR1 <- extract_cpgs_in_DMR(DMRx, dmr_tbl, annotated_tbl, pheno)
cpgs_DMR1
```

## 2- function: it creates a long format of the previous table
```{r}
library(tidyr)
library(dplyr)


reshape_to_long_beta <- function(region_cpgs, pheno_data) {
  # Input validation checks
  if (missing(region_cpgs)) stop("Error: 'region_cpgs' table is missing")
  if (missing(pheno_data)) stop("Error: 'pheno_data' table is missing")
  
  # Convert to data frames
  region_cpgs_df <- as.data.frame(region_cpgs)
  pheno_df <- as.data.frame(pheno_data)
  
  # Column validation
  required_cols <- c("chr", "pos")
  if (!all(required_cols %in% colnames(region_cpgs_df))) {
    stop("Missing required columns in region_cpgs: 'chr' and/or 'pos'")
  }
  if (!"Sample_Group" %in% colnames(pheno_df)) {
    stop("Missing 'Sample_Group' column in pheno_data")
  }

  # Sample handling
  m <- nrow(pheno_df)
  beta_cols <- tail(colnames(region_cpgs_df), m)
  
  # Beta value validation
  beta_values <- region_cpgs_df[, beta_cols, drop = FALSE]
  if (!all(vapply(beta_values, is.numeric, logical(1)))) {
    stop("Non-numeric values found in beta columns")
  }
  if (any(beta_values < 0 | beta_values > 1, na.rm = TRUE)) {
    stop("Beta values outside [0,1] range detected")
  }

  # Create CpG identifier
  if (!"CpGName" %in% colnames(region_cpgs_df)) {
    region_cpgs_df$CpGName <- rownames(region_cpgs_df)
  }

  # Core processing pipeline
  region_cpgs_df %>%
  dplyr::arrange(.data$pos) %>%
  tidyr::pivot_longer(
    cols = all_of(beta_cols),
    names_to = "SampleID",
    values_to = "BetaValue"
  ) %>%
  dplyr::mutate(
    SampleID = gsub("^X", "", SampleID),  # X am Anfang entfernen!
    Group = pheno_df$Sample_Group[match(SampleID, rownames(pheno_df))],
    PositionLabel = paste(.data$CpGName, "\npos=", .data$pos)
  ) %>%
  dplyr::select(
    "chr", "pos", "CpGName", "SampleID", "Group", "BetaValue", "PositionLabel"
  )
}


#try function:
# from the previous fuction test
# pheno
long_DMR1 <- reshape_to_long_beta(cpgs_DMR1, pheno)
head(long_DMR1)
```

## 3- function of boxplots
```{r}
library(ggplot2)
library(plotly)
# Define the function
create_boxplot <- function(long_format_table, interactive = FALSE, use_positional_spacing = FALSE) {
  if (length(unique(long_format_table$chr)) != 1) {
    stop("Error: Not all CpGs are on one chromosome.")
  }

  # Correct x-axis variable name as string
  x_col <- if (use_positional_spacing) "pos" else "PositionLabel"
  
  # Define text aesthetics for tooltips
  long_format_table$text <- if (interactive) {
    if (use_positional_spacing) {
      paste0(long_format_table$SampleID, "\n", long_format_table$PositionLabel)
    } else {
      long_format_table$SampleID
    }
  } else {
    long_format_table$SampleID  # You still need a column, even if it's ignored
  }

  p <- ggplot(long_format_table, aes_string(x = x_col, y = "BetaValue", fill = "Group")) +
    geom_boxplot(
                 aes_string(group = "interaction(pos, Group)", color = "Group"),
                 outlier.shape = NA, color = "black", lwd = 0.3) +
    theme_minimal() +
    scale_fill_manual(values = c("guided" = "red", "unguided" = "blue")) +
    labs(
      x = if (use_positional_spacing) paste("Position on", unique(long_format_table$chr)) else paste("CPG + Position on", unique(long_format_table$chr)),
      y = "Beta Value",
      fill = "Group"
    ) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))

  if (interactive) {
  p <- suppressWarnings(
    p + geom_jitter(aes_string(color = "Group", text = "text"), width = 0.2, height = 0, shape = 16)
  )
  return(plotly::ggplotly(p, tooltip = "text"))
} else {
  p <- suppressWarnings(
    p + geom_jitter(aes_string(color = "Group"), width = 0.2, height = 0, shape = 16) 
  )
  return(p)
  }
}
create_boxplot(long_DMR1, interactive = TRUE, use_positional_spacing = FALSE)

```



