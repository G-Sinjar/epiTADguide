---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.


# library
```{r}
library(minfi)
library("IlluminaHumanMethylationEPICv2manifest")
```

# Reading the SampleSheet file
```{r}
RawDataDir <- "C:\\Users\\ghaza\\Documents\\ghazal\\Bioinformatik_Fächer\\Masterarbeit_Project\\Data\\CLDN10_RawData\\epic_data\\2024_071_ILL_METUVG_N_8\\METUVG"

targets <- read.metharray.sheet(RawDataDir)
```

# Load methydata from idat files 
```{r}
RGset <- read.metharray.exp(targets = targets)

manifest <- getManifest(RGset)
#manifest

raw_normalised <- preprocessRaw(RGset)
```

#QC

# Normalisation
```{r}
set.seed(123)
SWAN_normalised <- preprocessSWAN(RGset, raw_normalised)
```


# Filtering 0,01
```{r}
#---------------first level filtering: cpgs that passed the threshold in all samples ----------
detectp <- detectionP(RGset)
#dim(detectp) #936990      8

# 2. Absent vector
all.equal(row.names(SWAN_normalised), row.names(detectp))  #TRUE
absent_0.01 <- apply(detectp, 1, function(x) sum(x>0.01)) 
table(absent_0.01) #-> 911931 -_>  97.32559%

# 3. Filtering SWAN: Absent == 0 --> the probe is relaiably detected in all samples
SWAN_filtered_0.01 <- SWAN_normalised[absent_0.01 == 0] # 911931   
```


# Map to the Genome:
```{r}
Geno_SWAN_filtered_0.01 <- mapToGenome(SWAN_filtered_0.01, mergeManifest = TRUE)
dim(Geno_SWAN_filtered_0.01) # 905075
```

# Convert GenoMethylSet to a GenoRatioSet (Beta + M): 
```{r}
ratio_geno_Swan_0.01 <- ratioConvert(Geno_SWAN_filtered_0.01,what = "both", keepCN= TRUE)
dim(ratio_geno_Swan_0.01) #905075       8
```

# removing SNPs 
```{r}
snps_0.01 <- getSnpInfo(ratio_geno_Swan_0.01)
ratio_geno_Swan_0.01 <- addSnpInfo(ratio_geno_Swan_0.01)
ratio_geno_Swan_NoSNP <- dropLociWithSnps(ratio_geno_Swan_0.01, snps = c("SBE", "CpG"), maf = 0)
ratio_geno_Swan_NoSNP # 891492
```



# Get annotation data
```{r}
annotation <- getAnnotation(ratio_geno_Swan_NoSNP)
annotation_df <- as.data.frame(annotation)
#dim(annotation_df) # 891492     42

ratio_geno_Swan_NoSNP_Beta <- getBeta(ratio_geno_Swan_NoSNP)

# 2. Combine methylation values with annotation:
if (identical(rownames(annotation_df),rownames(ratio_geno_Swan_NoSNP_Beta))){ 
    annotated_with_betas <- cbind(annotation, ratio_geno_Swan_NoSNP_Beta)
} 
#dim(annotated_with_betas) #  896581     50
annotated_with_betas_df <- as.data.frame(annotated_with_betas)
#View(annotated_with_betas_df)
```

# Preparing for bumhunter
```{r}
# 1. Define the phenotype of interest
pheno <- pData(ratio_geno_Swan_NoSNP)$Sample_Group
# 2. Change the reference level to "unguided" so the value is minus on chr13 target
if (!is.factor(pheno)) {
  pheno <- factor(pheno)
}
pheno <- relevel(pheno, ref = "unguided")


# 3. designMatrix
designMatrix <- model.matrix(~ pheno)
```


# DMRs cutoff 0,15  B=100  smooth= FALSE
```{r}
library(doParallel)
registerDoParallel(cores = 4)

dmrs <- bumphunter(ratio_geno_Swan_0.05_NoSNP, design = designMatrix, cutoff = 0.15, B=100, type="Beta", maxGap = 500)

#dim(dmrs2$table) #1067   15
View(dmrs2$table)
```


# DMRs with cutoff=0.15,   B=100   smooth = TRUE
```{r}
library(doParallel)
registerDoParallel(cores = 6)

dmrs <- bumphunter(ratio_geno_Swan_NoSNP, design = designMatrix, cutoff = 0.15, B=100, type="Beta", smooth = TRUE) 
head(dmrs)
#0,2 B=0 --> 1dmr chr6
#0,15 B=0 --> 16 DMR
#0,15 B=100 --> 16 DMR
```

# Editing the DMR table
```{r}
#library(dplyr)
DMRtable <- dmrs$table

# ------ Add DMR length -----------
DMRtable$length <- DMRtable$end - DMRtable$start

#--------sort DMRs from the longest ----------
DMRtable<- DMRtable[order(DMRtable$length, decreasing = TRUE), ]

#--------add DMR.Nr. column ---------
DMRtable$DMR_Nr <- seq_len(nrow(DMRtable))

#------- change the pvalue from scientific to normal values----------
DMRtable$p.value <- format(DMRtable$p.value, scientific = FALSE)

#------- change the pvalue from scientific to normal values----------
DMRtable <- DMRtable %>% rename(mean.methy.difference  =value)
DMRtable <- DMRtable %>% rename(CpGs.inDMR  =L)
DMRtable <- DMRtable %>% rename(CpGs.inCluster  =clusterL)

#------ reorder the columns --------------
column_order <- c("DMR_Nr", "chr","start", "end", "length","mean.methy.difference", "CpGs.inDMR", "CpGs.inCluster" ,"p.value" ,"fwer" ,setdiff(names(DMRtable), c("DMR_Nr","chr" ,"start", "end", "length","mean.methy.difference", "CpGs.inDMR", "CpGs.inCluster","p.value" ,"fwer")))
DMRtable <- DMRtable[, column_order]


dmrs_0.01_smooth <- DMRtable
rm(DMRtable)
View(dmrs_0.01_smooth)
```

# test
```{r}
setdiff(dmrs_smooth$start, dmrs_0.01_smooth$start) #76422394  80002882 159094539 138138669
missimg_cpgs <- dmrs_smooth[dmrs_smooth$start %in% c(76422394, 80002882, 159094539, 138138669), ]
View(missimg_cpgs)
```

# save/ get DMR table
```{r}
writexl::write_xlsx(dmrs_0.01_smooth, "./Output/DMRs_0.01_smooth.xlsx")


# get dmrs_smooth from excel
library(readxl)
dmrs_smooth <- read_excel("./Output/8-DMRs_0.01_smooth.xlsx")
View(dmrs_smooth) 
```



# 1. DMRs no smoothing ########################
## 1 Bind with cpgs DMR2 
```{r}
# Binding to annotation table to get cpgs infos:
cpgs_DMR2_chr13 <- annotated_with_betas_df[annotated_with_betas_df$chr == "chr13" & 
                       annotated_with_betas_df$pos >= DMRs_b100$start[2]& 
                       annotated_with_betas_df$pos <= DMRs_b100$end[2], ]
View(cpgs_DMR2_chr13)
```

## 1 creating a table ready for boxplots of all cpgs in one DMR
```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(plotly)
library(htmlwidgets)


beta_long <- cpgs_DMR2_chr13 %>%
  rowwise() %>%
  pivot_longer(
    cols = 43:50,  # Selecting beta value columns
    names_to = "SampleID",
    values_to = "BetaValue"
  ) %>%
  mutate(
    Group = pheno[match(SampleID, colnames(cpgs_DMR2_chr13)[43:50])],  # Match sample to Group
    Position = rep(cpgs_DMR2_chr13$pos, each = length(43:50)),
    CpGName = rownames(cpgs_DMR2_chr13)[rep(1:nrow(cpgs_DMR2_chr13), each = length(43:50))]  # Extract CpG names from rownames
  ) %>%
  ungroup() %>%
  select(Position, SampleID, BetaValue, Group, CpGName)  # Select desired columns

# 0rder the cpgs according to pos
beta_long<- beta_long[order(beta_long$Position, decreasing = FALSE), ]

beta_long <- beta_long %>%
  mutate(PositionLabel = paste(paste0("pos. ", Position), CpGName, sep = "\n"))  # Combine position and CpGName

View(beta_long)
```


## 1 Boxplots of cpgs in one DMR
```{r}
# Basic Boxplot with Dotted Lines from Whiskers to Outliers
p <- ggplot(beta_long, aes(x = factor(PositionLabel), y = BetaValue, fill = Group)) +
  geom_boxplot(outlier.shape = NA) +  # Remove default outlier points
  geom_jitter(aes(color = Group, text = SampleID), width = 0.2, height = 0, shape = 16) +  # Add outlier points manually
  theme_minimal() +
  scale_fill_manual(values = c("guided" = "blue", "unguided" = "red")) +  # Custom colors
  labs(x = "CPG + Position on Chr13", y = "Beta Value", fill = "Group") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p

# interactive boxplot
interactive_plot <- ggplotly(p, tooltip = "text")  # Use 'text' to show the SampleID when hovering

# Save the interactive plot as an HTML file
saveWidget(interactive_plot, "interactive_boxplot_DMR2.html")
```








# 2. DMRs with smoothing ########################
## 2 bind to cpps DMR1 smooth
```{r}
# Binding to annotation table to get cpgs infos:
cpgs_DMR1 <- annotation_0.01_df[annotation_0.01_df$chr == "chr13" & 
                       annotation_0.01_df$pos >= dmrs_smooth$start[1]& 
                       annotation_0.01_df$pos <= dmrs_smooth$end[1], ]
View(cpgs_DMR1)
```


## 2 get dmp table
```{r}
View(dmp)

# get dmp_NoShrink from excel
library(readxl)
dmp <- read_excel("./Output/7-DMPs_NoShrink_0,01.xlsx")
View(dmp)
```


## test ### test #### filter cpgs before DMRs/ bumphunter
```{r}
# Filter the DMP table to keep only rows where pval >= 0.05
filtered0.05_dmp <- dmp[dmp$pval <= 0.05, ]
dim(filtered0.05_dmp) #40541     6
############### bullshit

#bumphunter
## End Test ---> DIDNT WORK
```






## 3 Add columns (pval, beta and M differnces) to the cpgs_DMR1 
```{r}
# 1. get-pvalue from dmp table
cpgs_DMR1_pval <- dmp[rownames(cpgs_DMR1), ]
View(cpgs_DMR1_pval)

identical(rownames(cpgs_DMR1_pval), rownames(cpgs_DMR1)) # true

# 2. Add the extracted values as new columns in cpgs_DMR1
cpgs_DMR1$P.Value <- cpgs_DMR1_pval$pval
cpgs_DMR1$Beta_Difference <- cpgs_DMR1_pval$beta_difference
cpgs_DMR1$M_Difference <- cpgs_DMR1_pval$M_difference

View(cpgs_DMR1)
```

# DMR1
## a-create a table for boxplot of cpgs in one DMR1  
```{r}
# create the box plot table
library(dplyr)

cpgs_DMR1_for_boxplot <- cpgs_DMR1 %>% select(chr, pos, strand, P.Value, 35:42)

View(cpgs_DMR1_for_boxplot)

# save and send to cornelia
writexl::write_xlsx(cpgs_DMR1_for_boxplot, "./Output/cpgs_in_DMR1_forBoxplots.xlsx")
```


## b-  creating a long format table ready for boxplots of all cpgs in one DMR
```{r}
library(tidyr)

beta_long_smooth <- cpgs_DMR1_for_boxplot %>%
  rowwise() %>%
  pivot_longer(
    cols = 5:12,  # Selecting beta value columns
    names_to = "SampleID",
    values_to = "BetaValue"
  ) %>%
  mutate(
    Group = pheno[match(SampleID, colnames(cpgs_DMR1_for_boxplot)[5:12])],  # Match sample to Group
    Position = rep(cpgs_DMR1_for_boxplot$pos, each = length(5:12)),
    CpGName = rownames(cpgs_DMR1_for_boxplot)[rep(1:nrow(cpgs_DMR1_for_boxplot), each = length(5:12))],
  ) %>%
  ungroup() %>%
  select(Position, SampleID, BetaValue, Group, CpGName)  # Select desired columns

# 0rder the cpgs according to pos
beta_long_smooth <- beta_long_smooth[order(beta_long_smooth$Position, decreasing = FALSE), ]

 
# add this column from dmps
beta_long_smooth <- beta_long_smooth %>%
  mutate(P.Value = cpgs_DMR1_for_boxplot$P.Value[match(CpGName, rownames(cpgs_DMR1_for_boxplot))])

beta_long_smooth <- beta_long_smooth %>%
  mutate(PositionLabel = paste(CpGName, "\n", "pval =", round(P.Value, 5)))

View(beta_long_smooth)

# save and send to cornelia
writexl::write_xlsx(beta_long_smooth, "./Output/longformat_cpgs_in_DMR1_forBoxplots.xlsx")
```




# 2 basic interactive Boxplots of cpgs in one DMR
```{r}
p2 <- ggplot(beta_long_smooth, aes(x = factor(PositionLabel), y = BetaValue, fill = Group)) +
  geom_boxplot(outlier.shape = NA) +  # Remove default outlier points
  geom_jitter(aes(color = Group, text = SampleID), width = 0.2, height = 0, shape = 16) +  # Add outlier points manually
  theme_minimal() +
  scale_fill_manual(values = c("guided" = "blue", "unguided" = "red")) +  # Custom colors
  labs(x = "CPG + Position on Chr13", y = "Beta Value", fill = "Group") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p2
interactive_plot2 <- ggplotly(p2)
interactive_plot2
```

# 2 interactiv boxplots: position on chr related  # PositionLabel oben
```{r}
# P3: distanz zwischen Boxes ist abhängig von echte Distanz 
p3 <- ggplot(beta_long_smooth, aes(x = Position, y = BetaValue, fill = Group)) +
  geom_boxplot(outlier.shape = NA, width = 2) +  
  geom_jitter(aes(color = Group), width = 0.2, height = 0, shape = 16) +  
  theme_minimal() +
  scale_fill_manual(values = c("guided" = "blue", "unguided" = "red")) +  
  labs(x = "Genomische Position auf Chr13", y = "Beta Value", fill = "Group") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  
  # PositionLabel über den Boxplots anzeigen
  geom_text(data = beta_long_smooth, 
            aes(x = Position, y = max(beta_long_smooth$BetaValue) + 0.05, 
                label = PositionLabel), 
            angle = 45, hjust = 0.5, size = 3)

# Interaktiven Plot mit ggplotly erstellen
interactive_plot3 <- ggplotly(p3)
interactive_plot3
```



#2 interactiv boxplots: position on chr related
```{r}
# P4: PositionLabel interaktiv
p4 <- ggplot(beta_long_smooth, aes(x = Position, y = BetaValue, fill = Group)) +
  geom_boxplot(outlier.shape = NA, width = 2) +  
  geom_jitter(aes(color = Group, text = paste0(PositionLabel, "\n", SampleID)), 
              width = 0.2, height = 0, shape = 16) +  
  theme_minimal() +
  scale_fill_manual(values = c("guided" = "blue", "unguided" = "red")) +  
  labs(x = "Genomische Position auf Chr13", y = "Beta Value", fill = "Group") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Interaktive Plotly-Visualisierung mit Tooltips aktivieren
interactive_plot4 <- ggplotly(p4, tooltip = "text")
interactive_plot4

# Save the interactive plot as an HTML file
saveWidget(interactive_plot4, "interactive_boxplot_DMR2_smooth_pval_4.html")
```  