---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 


Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.



####################################### script ################################
# library
```{r}
library(minfi)
library("IlluminaHumanMethylationEPICv2manifest")
library(openxlsx)
library(dplyr)
library(readxl)
library(ggplot2)
library(plotly)
library(htmlwidgets)
```

# DMP finder prepareing steps
## 1- get beta values, M values and phen
```{r}
beta_values <- read.xlsx("./Output/2-Beta_values_SWAN_0.01.xlsx", rowNames = TRUE)
M_values <- read.xlsx("./Output/3-M_values_SWAN_0.01.xlsx",, rowNames = TRUE)
View(M_values)
pheno
# or
# Convert guide_status to a factor (if it isn't already)
guide_status <- factor(pData(ratio_geno_Swan_0.01_NoSNP)$Sample_Group)
# Change the reference level to "unguided"
guide_status <- relevel(guide_status, ref = "unguided")

#-------------------06.08.2025
dir <- "C:/Users/ghaza/Documents/ghazal/Bioinformatik_Fächer/Masterarbeit_Project/Scripts/R_Scripts/modules/main_app_tests/box_pheno_pass/intermediate_data/Five_objects_normalised_data.rds"
methylsets <- readRDS(dir)

# pheno (used script 2.)
pheno_table <- pData(methylsets$SWAN)
pheno <- pheno_table$Sample_Group

beta_values <- getBeta(methylsets$SWAN)
M_values <- getM(methylsets$SWAN)
```

# 2-function to cumpute getting beta and m mean difference
```{r}
calculateMethylationMeanDifferences <- function(normalised_methylset, pheno_table, ref_group, round_digits = 5) {

  # 1. Get Beta and M values using tryCatch for robust error handling
  beta_values <- tryCatch({
    # Attempt to get Beta values. This assumes 'getBeta' is available
    # and compatible with 'normalised_methylset' (e.g., from 'minfi').
    getBeta(normalised_methylset)
  }, error = function(e) {
    message("Error getting Beta values: ", e$message)
    return(NULL) # Return NULL on error
  })

  M_values <- tryCatch({
    # Attempt to get M values. This assumes 'getM' is available
    # and compatible with 'normalised_methylset' (e.g., from 'minfi').
    getM(normalised_methylset)
  }, error = function(e) {
    message("Error getting M values: ", e$message)
    return(NULL) # Return NULL on error
  })

  # Check if Beta or M values could not be retrieved
  if (is.null(beta_values) || is.null(M_values)) {
    stop("Could not retrieve Beta or M values. Please check 'normalised_methylset' object and 'minfi' package availability.")
  }

  # Ensure column names of beta/M matrices match row names of pheno_table.
  # This is crucial for correctly mapping samples to their groups.
  if (!all(colnames(beta_values) %in% rownames(pheno_table))) {
    stop("Column names of beta values do not fully match row names of pheno table.
          Please ensure sample IDs are consistent.")
  }
  if (!all(colnames(M_values) %in% rownames(pheno_table))) {
    stop("Column names of M values do not fully match row names of pheno table.
          Please ensure sample IDs are consistent.")
  }

  # Order the pheno_table to match the column order of the methylation data.
  # This ensures correct group assignment for each sample column.
  pheno_ordered <- pheno_table[colnames(beta_values), , drop = FALSE]

  # 2. Identify and validate groups
  if (!"Sample_Group" %in% colnames(pheno_ordered)) {
    stop("Phenotype table must contain a column named 'Sample_Group'.")
  }

  all_groups <- unique(pheno_ordered$Sample_Group)
  if (!ref_group %in% all_groups) {
    stop(paste0("Reference group '", ref_group, "' not found in the 'Sample_Group' column.
                Available groups are: ", paste(all_groups, collapse = ", ")))
  }

  # Identify the 'other' group. This function is designed for exactly two groups.
  other_groups <- setdiff(all_groups, ref_group)
  if (length(other_groups) != 1) {
    stop(paste0("This function is designed for exactly two groups (reference and one other).
                Found groups: ", paste(all_groups, collapse = ", ")))
  }
  other_group_name <- other_groups[1]

  # Get the sample IDs for each group based on the ordered phenotype table.
  ref_sample_names <- rownames(pheno_ordered)[pheno_ordered$Sample_Group == ref_group]
  other_sample_names <- rownames(pheno_ordered)[pheno_ordered$Sample_Group == other_group_name]

  # 3. Subset Beta values by group
  # 'drop = FALSE' ensures that the result remains a matrix even if only one sample is present.
  beta_ref <- beta_values[, ref_sample_names, drop = FALSE]
  beta_other <- beta_values[, other_sample_names, drop = FALSE]

  # 4. Compute row-wise mean for each group (Beta values)
  mean_beta_ref <- rowMeans(beta_ref, na.rm = TRUE) # na.rm=TRUE handles potential NA values
  mean_beta_other <- rowMeans(beta_other, na.rm = TRUE)

  # 5. Compute Beta mean difference: log2(other_group) - log2(ref_group).
  # Add a small epsilon to avoid log2(0) or log2 of very small numbers, which can result in -Inf.
  epsilon <- 1e-9 # one of a billion
  Beta_mean_difference <- log2(mean_beta_other + epsilon) - log2(mean_beta_ref + epsilon)

  # 6. Subset M values by group
  M_ref <- M_values[, ref_sample_names, drop = FALSE]
  M_other <- M_values[, other_sample_names, drop = FALSE]

  # 7. Compute row-wise mean for each group (M values)
  mean_M_ref <- rowMeans(M_ref, na.rm = TRUE)
  mean_M_other <- rowMeans(M_other, na.rm = TRUE)

  # 8. Compute M mean difference: other_group - ref_group -> is the fold change
  M_mean_difference <- mean_M_other - mean_M_ref

  # 9. Round the final mean differences before combining
  M_mean_difference_rounded <- round(M_mean_difference, round_digits)
  Beta_mean_difference_rounded <- round(Beta_mean_difference, round_digits)

  # 10. Combine rounded mean differences into a single data frame
  # Row names will be the CpG IDs from the original methylation data.
  combined_results <- data.frame(
    M_mean_difference = M_mean_difference_rounded,
    Beta_mean_difference = Beta_mean_difference_rounded,
    row.names = rownames(beta_values) # CpG IDs
  )

  return(combined_results)
}


#test function
ref_group <- "unguided"
mean_beta_M_tbl <- calculateMethylationMeanDifferences(normalised_methylset = methylsets$SWAN, pheno_table = pheno_table, ref_group = ref_goup)
head(mean_beta_M_tbl)
```

## 2- compute the beta and M values 
```{r}
########## computing the beta values #############
# Subset the columns for unguided and guided samples
beta_unguided <- beta_values[, c(1, 3, 5, 7)] 
beta_guided <- beta_values[, c(2, 4, 6, 8)]   

# Compute row-wise mean for each group
mean_beta_unguided <- rowMeans(beta_unguided)
mean_beta_guided <- rowMeans(beta_guided)

# Compute the mean difference (guided - unguided)
#Beta_log2_meanSubstraction <- log2(mean_beta_guided - mean_beta_unguided)    # NAs wurde erzeugt
Beta_log2mean_Substraction <- log2(mean_beta_guided) - log2(mean_beta_unguided)


########## computing the M values #############
# Subset the columns for unguided and guided samples
M_unguided <- M_values[, c(1, 3, 5, 7)] 
M_guided <- M_values[, c(2, 4, 6, 8)]    

# Compute row-wise mean for each group
mean_M_unguided <- rowMeans(M_unguided)
mean_M_guided <- rowMeans(M_guided)

M_mean_difference <- mean_M_guided - mean_M_unguided

# add M_mean_difference and Beta_mean_difference later to the dmp tables
```


# Finding DMPs to check if the 10 cpgs have a sig. p-value 
```{r}
# 1. try
dmp <- dmpFinder(as.matrix(beta_values), pheno = pheno, type = "categorical", qCutoff = 1, shrinkVar = FALSE) 
#options(scipen = 999)
#View(dmp)

## 2. try with schrink
#dmp_shrink <- dmpFinder(ratio_geno_Swan_0.01_NoSNP_Beta, pheno = pheno, type = "categorical", qCutoff = 1, shrinkVar = TRUE) 
#Warnung: row names of contrasts don't match col names of coefficients
#View(dmp_shrink)

## 3. try with methyset -> worked
pheno_table <- pData(methylsets$SWAN)
pheno <- pheno_table$Sample_Group
dmp <- dmpFinder(methylsets$SWAN, pheno = pheno, type = "categorical", qCutoff = 1, shrinkVar = FALSE) 
dim(dmp) # 936990      4
head(dmp)
```
# Editing DMP table
```{r}
#Add M and Beta mean difference columns to a DMP (Differentially Methylated Positions) table.
addMeanDifferencesToDMP <- function(dmp_table, combined_Beta_M_mean_table) {
  tryCatch({
    # Ensure both tables have row names
    if (is.null(rownames(dmp_table))) {
      stop("'dmp_table' must have row names (CpG IDs).")
    }
    if (is.null(rownames(combined_Beta_M_mean_table))) {
      stop("'combined_Beta_M_mean_table' must have row names (CpG IDs).")
    }

    # Convert to data.frame if they aren't already
    dmp_df <- as.data.frame(dmp_table)
    mean_df <- as.data.frame(combined_Beta_M_mean_table)
    
    # Add the mean differences directly by row name matching
    dmp_df$M_mean_difference <- mean_df[rownames(dmp_df), "M_mean_difference"]
    dmp_df$Beta_mean_difference <- mean_df[rownames(dmp_df), "Beta_mean_difference"]
    
    return(dmp_df)

  }, error = function(e) {
    message("Error adding mean differences to DMP table: ", e$message)
    return(NULL)
  })
}

# test funtion
edited_dmp <- addMeanDifferencesToDMP(dmp_table = dmp, combined_Beta_M_mean_table = mean_beta_M_tbl)
dim(edited_dmp)
dim(mean_beta_M_tbl)
#Check if row names match exactly:
sum(rownames(dmp) %in% rownames(mean_beta_M_tbl)) == nrow(dmp)
#Check for NA values in the mean differences:
sum(is.na(mean_beta_M_tbl$Beta_mean_difference))
# check if it worked
# Correct way 1:
edited_dmp["cg24426691_TC11", ]$Beta_mean_difference  # should be -0.1545998
mean_beta_M_tbl["cg24426691_TC11", "Beta_mean_difference"]     

# Correct way 2:
mean_beta_M_tbl["cg06428163_BC21",]$Beta_mean_difference      # should be -0.2349488 
mean_beta_M_tbl$Beta_mean_difference[rownames(mean_beta_M_tbl) == "cg06428163_BC21"]  
```

## Editing the DMP table
```{r}
################## Add beta_mean_difference #############  change according to dmp table name #################
# 1. Match the row names of dmp with the names in mean_difference
#matching_indices <- match(rownames(dmp), names(mean_difference))
# Check if matching_indices contains any NA values (which means a row wasn't found)
#any(is.na(matching_indices)) # false

#dmp$beta_difference <- mean_difference[matching_indices]

# 3. check it worked
#dmp["cg24426691_TC11", ]$beta_difference  # -0.1545998
#mean_difference["cg24426691_TC11"]        # -0.1545998 

#mean_difference["cg06428163_BC21"]      # -0.2349488 
#dmp["cg06428163_BC21",]$beta_difference #  -0.2349488 



################## Add M_mean_difference #############  change according to dmp table name #################
# 1. Match the row names 
matching_indices_M <- match(rownames(dmp), names(M_mean_difference))

# Check if matching_indices contains any NA values (which means a row wasn't found)
if (any(is.na(matching_indices_M))) {
  print("Warning: Some rows in dmp were not found in mean_difference!") 
} else {
  dmp$M_difference <- M_mean_difference[matching_indices_M]
  print("All rows were found in both tables. M mean difference is added to the dmp table")
}

# 3. check it worked (2 targeted cpgs should be in minus)
dmp["cg24426691_TC11", ]$M_difference  # -1.126752
M_mean_difference["cg24426691_TC11"]   # -1.126752 

M_mean_difference["cg06428163_BC21"]      #  -1.577501
dmp["cg06428163_BC21",]$M_difference      #  -1.577501

View(dmp)
```

# Add GenType column for volcanoplot
```{r}
cpgs_inCLDN10_AB <- read_excel("./Output/6-cpgs_inCLDN10_A+B.xlsx", col_names = TRUE)

# Merge dmp with cpgs_inCLDN10_AB, keeping all rows from dmp
if (!"CpGs" %in% colnames(dmp)) {
  dmp$CpGs <- rownames(dmp)
}

dmp <- merge(dmp, cpgs_inCLDN10_AB[, c("CpGs", "GenType")], by = "CpGs", all.x = TRUE)

# Ersetze NA-Werte in GenType mit "Other"
dmp$GenType[is.na(dmp$GenType)] <- "Other"
  

View(dmp)
```


# Save DMP table as excel 
```{r}
dmp_with_rownames <- cbind(CpGs = rownames(dmp), dmp)
writexl::write_xlsx(dmp_with_rownames, "./Output/7-DMPs_NoShrink_0,01.xlsx")


#dmp <- read_excel("./Output/7-DMPs_NoShrink_0,01.xlsx", col_names = TRUE)
```


#  Volcano plot
```{r}
dim(dmp) #891492      7
# Make sure 'GenType' is a factor
dmp$GenType <- as.factor(dmp$GenType)


# since the html is so slow due to too many cpgs it is better to do a primary filter with pvalue 
# Keep only CpGs with significant p-values or non-"Other" categories
dmp_filtered <- dmp %>% filter(GenType != "Other" | pval < 0.08) 
dim(dmp_filtered) # 65430    7
```


```{r}
create_volcano_plot <- function(dmp_filtered, pval_cutoff , fc_range=c(-0.7, 0.7)) {
  
  y_intercept <- -log10(pval_cutoff)
  x_intercepts <- fc_range
  
  color_palette <- c(
    "CLDN10 Iso-A" = "blue",
    "CLDN10 Iso-B" = "purple",
    "Targeted CpG" = "green",
    "Other" = "gray"
  )
  
  plot_m <- ggplot(dmp_filtered, aes(
    y = -log10(pval),
    x = M_difference,
    color = GenType,
    text = paste0(
      CpGs,
      "<br>FC: ", round(M_difference, 5),
      "<br>p.val: ", round(pval, 5)
    )
  )) +
    geom_point(size = 0.7, alpha = ifelse(dmp_filtered$GenType == "Other", 0.3, 1)) +
    geom_hline(yintercept = y_intercept, linetype = "dashed", color = "red") +
    geom_vline(xintercept = x_intercepts, linetype = "dashed", color = "red") +
    
    annotate("text", x = max(dmp_filtered$M_difference, na.rm = TRUE) * 0.95, y = y_intercept * 0.9,
             label = paste("p-val =", pval_cutoff), hjust = 0, vjust = -1, color = "red", fontface = "bold") +
    
    annotate("text", x = x_intercepts[1] * 0.9, y = min(-log10(dmp_filtered$pval), na.rm = TRUE) * 1.1,
             label = as.character(x_intercepts[1]), hjust = -0.2, vjust = 1.5, color = "red") +
    
    annotate("text", x = x_intercepts[2] * 0.9, y = min(-log10(dmp_filtered$pval), na.rm = TRUE) * 1.1,
             label = as.character(x_intercepts[2]), hjust = 1.2, vjust = 1.5, color = "red") +
    
    labs(x = "FC = log₂(M/U)", y = "-log10(p-value)", title = "Differentially Methylated Probes") +
    scale_color_manual(values = color_palette) +
    guides(color = guide_legend(title = "CpG Categories")) +
    theme_minimal()
 plot_m
  #ggplotly(plot_m, tooltip = "text")
}

# Remove hover tooltips for "Other" points
#for (i in seq_along(interactive_plot$x$data)) {
#  if ("name" %in% names(interactive_plot$x$data[[i]]) && interactive_plot$x$data[[i]]$name == "Other") {
#    interactive_plot$x$data[[i]]$hoverinfo <- "none"
#  }
#}


#test
create_volcano_plot(dmp_filtered ,0.02, c(-0.7, 0.7))

# Save as an interactive HTML file
#saveWidget(interactive_plot, "./Plots/dmps_CLDN10_colored_filtered_0.02.html", selfcontained = TRUE)
```

# ---- Shiny App ---- very slow dont make any sence
```{r}
volcano_ui <- fluidPage(
  titlePanel("Interactive Volcano Plot Viewer"),
  sidebarLayout(
    sidebarPanel(
      numericInput("pval", "P-value cutoff:", value = 0.02, min = 0.0001, max = 1, step = 0.001),
      sliderInput("fc_range", "Fold change range:", min = -2, max = 2, value = c(-0.7, 0.7), step = 0.01),
      actionButton("submit", "Submit"),
      br(), br(),
      downloadButton("savePlot", "Download Plot as HTML")
    ),
    mainPanel(
      plotlyOutput("volcanoPlot", height = "600px")
    )
  )
)

volcano_server <- function(input, output,session) {
  
  volcano_plot <- eventReactive(input$submit, {
    create_volcano_plot(dmp_filtered, pval_cutoff = input$pval, fc_range = input$fc_range)
  })
  
  #output$volcanoPlot <- renderPlotly({
    #volcano_plot()
  #})
  
  output$savePlot <- downloadHandler(
    filename = function() {
      paste("volcano_plot_", "_pval_", input$pval,"FC[", input$fc_range, "].html", sep = "")
    },
    content = function(file) {
      saveWidget(volcano_plot(), file)
    }
  )
}

shinyApp(volcano_ui, volcano_server)
```