---
title: "fertige pipline"
author: "Ghazal Sinjar"
date: "2024-12-16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.











# library
```{r}
library(minfi)
```

# Reading the SampleSheet file
```{r}
RawDataDir <- "C:\\Users\\ghaza\\Documents\\ghazal\\Bioinformatik_Fächer\\Masterarbeit_Project\\Data\\RawData\\epic_data\\2024_071_ILL_METUVG_N_8\\METUVG"

targets <- read.metharray.sheet(RawDataDir)
#writexl::write_xlsx(targets, "./Output/Samples-targets.xlsx")
```


# Load methydata from idat files 
```{r}
RGset <- read.metharray.exp(targets = targets)
RGset #1105209 # assays red + green

library("IlluminaHumanMethylationEPICv2manifest")
manifest <- getManifest(RGset)
manifest

## duplicates finding
probeIDs <- featureNames(RGset)  # For RGChannelSet or MethylSet
anyDuplicated(probeIDs)


raw_normalised <- preprocessRaw(RGset)
#raw_normalised # assays: Meth + Unmeth #936990
```

# Quality control:
```{r}
# plot raw Intensities
png("./Plots/red_green_channel_plot.png", width = 800, height = 600)
plot(density(as.vector(assay(RGset, "Red"))), main = "Channel Intensities", lwd = 2) 
lines(density(as.vector(assay(RGset, "Green"))), col = "green", lwd = 2)
legend("topright", legend = c("Red Channel", "Green Channel"), col = c("black", "green"), lwd = 2)
dev.off()


## Badewanne plot: Beta plot (probability density plot)
densityPlot(RGset, sampGroups = targets$Sample_Label, main ="Beta values distribution of raw data", xlab = "Beta values")

## Bean plot 
par(mar = c(5, 6, 4, 2)) # Bottom, left, top, right margins (default is c(5, 4, 4, 2))
densityBeanPlot(RGset, sampGroups = targets$Sample_Label, sampNames = targets$Sample_Name)

## QC report
qcReport(RGset, sampNames = targets$Sample_Name, sampGroups = targets$Sample_Group0, pdf = "qcReport.pdf" )

# MDS plot (multi dimensional scaling plot) samples PCA
par(mfrow = c(2, 3), mar = c(1.7, 1.7, 1.4, 0.4)) 
mdsPlot(RGset, sampNames = targets$Array, sampGroups = targets$Sample_Group ,main = "Raw Beta MDS", legendNCol = 1, legendPos = "topright")

mdsPlot(noob_normalised, sampNames = targets$Array, sampGroups = targets$Sample_Group, main = "noob Beta MDS", legendNCol = 1, legendPos = "topright")
mdsPlot(SWAN_normalised, sampNames = targets$Array, sampGroups = targets$Sample_Group, main = "SWAN Beta MDS", legendNCol = 1 ,legendPos = "topright")
mdsPlot(getBeta(funnorm_normalised), sampNames = targets$Array, sampGroups = targets$Sample_Group, main = "funnorm Beta MDS", legendNCol = 1,legendPos = "topright")
mdsPlot(getBeta(Quantile_normalised), sampNames = targets$Array, sampGroups = targets$Sample_Group, main = "Quantile Beta MDS ", legendNCol = 1,legendPos = "topright")


# Badewanne mit probe types
pdf("plot_comparison.pdf", width=12, height=6)  # Larger PDF
par(mfrow=c(1,2))
plotBetasByType(raw_normalised[,1], main = "Raw")
plotBetasByType(SWAN_normalised[,1], main = "SWAN")
dev.off() 

#### sample-specific QC
qc <- getQC(raw_normalised)
qc   # log2 Medien plot: Methy and unmeth intensities
raw_normalised <- addQC(raw_normalised, qc)
plotQC(qc)
pData(raw_normalised)
```




# Normalisation
```{r}
#Quantile_normalised <- preprocessQuantile(RGset, fixOutliers = TRUE,removeBadSamples = TRUE, badSampleCutoff = 10.5, quantileNormalize = TRUE, stratified = TRUE, mergeManifest = FALSE, sex = NULL)
#funnorm_normalised <- preprocessFunnorm(RGset)
#noob_normalised <- preprocessNoob(RGset)
#set.seed(123)
#noob.swan_normalised <- preprocessSWAN(RGset, mSet = noob_normalised, verbose = TRUE)

set.seed(123)
SWAN_normalised <- preprocessSWAN(RGset, raw_normalised)
```

## Beta values Badewanne plot
```{r}
densityPlot(raw_normalised,sampGroups = targets$Sample_Label,main = "Beta Values distribution after raw normalisation", pal = rainbow(length(unique(targets$Sample_Label))))

densityPlot(noob_normalised, sampGroups = targets$Sample_Label ,main = "Beta values distribution after Noob", pal = rainbow(length(unique(targets$Sample_Label))))

densityPlot(funnorm.beta_values,sampGroups = targets$Sample_Label,main = "Beta Values distribution after Funnorm normalisation", pal = rainbow(length(unique(targets$Sample_Label))))

densityPlot(Quantile.beta_values,sampGroups = targets$Sample_Label,main = "Beta Values distribution after Quantile normalisation", pal = rainbow(length(unique(targets$Sample_Label))))

densityPlot(SWAN_normalised, sampGroups = targets$Sample_Label , main = "Beta values distribution after SWAN normalisation", pal = rainbow(length(unique(targets$Sample_Label))))

densityPlot(noob.swan_normalised,sampGroups = targets$Sample_Label, main = "Beta values distribution after Noob-SWAN", pal = rainbow(length(unique(targets$Sample_Label))))
```


# Filtering (p-value 0,01 immer)
```{r}
#---------------first level filtering: cpgs that passed the threshold in all samples --> sample reliability----------
detectp <- detectionP(RGset)
#dim(detectp) #936990      8

all.equal(row.names(SWAN_normalised), row.names(detectp))  #TRUE
absent <- apply(detectp, 1, function(x) sum(x>0.01)) 
table(absent) #-> 911931 -_>  97.32559%

SWAN_filtered <- SWAN_normalised[absent == 0] # 911931 

#getMeth()
#getUnmeth()
```


# Map to the Genome:
```{r}
library(IlluminaHumanMethylationEPICv2anno.20a1.hg38)

Geno_SWAN_filtered <- mapToGenome(SWAN_filtered, mergeManifest = TRUE)
#dim(Geno_SWAN_filtered) #905075
# assays methy unmethyl
```

# Convert GenoMethylSet to a GenoRatioSet (Beta + M): 
```{r}
ratio_geno_Swan <- ratioConvert(Geno_SWAN_filtered,what = "both", keepCN= TRUE)
#dim(ratio_geno_Swan) #905075      8

assays() # beta M CN
getBeta()
getM()
getCN()
sampleNames()
featureNames() # cpg names
pData()
```

# removing SNPs 
```{r}
snps <- getSnpInfo(ratio_geno_Swan)
ratio_geno_Swan <- addSnpInfo(ratio_geno_Swan)
ratio_geno_Swan_NoSNP <- dropLociWithSnps(ratio_geno_Swan, snps = c("SBE", "CpG"), maf = 0)
#891492    8
```

# Get annotation data
```{r}
annotation <- getAnnotation(ratio_geno_Swan_NoSNP)
#dim(annotation) #891492     42 -> 100%

annotation_df <- as.data.frame(annotation)
#View(annotation_df)


ratio_geno_Swan_NoSNP_Beta <- getBeta(ratio_geno_Swan_NoSNP)

# 2. Combine methylation values with annotation:
if (identical(rownames(annotation_df),rownames(ratio_geno_Swan_NoSNP_Beta))){ 
    annotated_with_betas <- cbind(annotation, ratio_geno_Swan_NoSNP_Beta)
} 
#dim(annotated_with_betas) #  896581     50
annotated_with_betas_df <- as.data.frame(annotated_with_betas)
# View(annotated_with_betas_df)
```


# get lage auf dem Chr -> file from ucsc -> the lines dont have a consistence length -> didnt work
```{r}
library(rtracklayer)
library(dplyr)

# Define the local path where the file should be saved
local_file_path <- "cytoBand_hg38.txt.gz"
url <- "http://hgdownload.cse.ucsc.edu/goldenpath/hg38/database/cytoBand.txt.gz"

# Check if the file already exists locally
if (!file.exists(local_file_path)) {
  # If the file does not exist, download it
  download.file(url, destfile = local_file_path)
  cat("File downloaded.\n")
} else {
  cat("File already exists locally.\n")
}
```


# get chromosomal band from ensembl -> didnt work
```{r}
library(biomaRt)

# Connect to Ensembl biomart
ensembl <- useEnsembl(biomart = "ENSEMBL_MART_ENSEMBL", dataset = "hsapiens_gene_ensembl", GRCh = 38)
# didnt work erscheint the webseit is not working


# Get the cytoband information
cytobands_ensembl <- getBM(
  attributes = c("chromosome_name", "start_position", "end_position", "band"),
  mart = ensembl
)

# Rename columns to match UCSC style
colnames(cytobands_ensembl) <- c("chrom", "chromStart", "chromEnd", "name")

# Remove non-standard chromosomes (like patches and alternative sequences)
cytobands_ensembl <- cytobands_ensembl[grepl("^\\d+$|^X$|^Y$", cytobands_ensembl$chrom), ]

# Convert chromosome numbers to UCSC format (e.g., "1" → "chr1")
cytobands_ensembl$chrom <- paste0("chr", cytobands_ensembl$chrom)

# Check results
head(cytobands_ensembl)

```




# get cytoband from sigminer
```{r}
#install.packages("sigminer")
library(sigminer)

cytobands_hg38 <- sigminer::cytobands.hg38

View(cytobands.hg38)
```

# add the cytobands to annotation table --> didnt work until now -> maybe add in another step where the table is smaller
```{r}
library(dplyr)

# Ensure pos, start, and end are numeric
annotation_df$pos <- as.numeric(annotation_df$pos)
cytobands_hg38$start <- as.numeric(cytobands_hg38$start)
cytobands_hg38$end <- as.numeric(cytobands_hg38$end)

# Merge annotation_df with cytobands, keeping all rows from annotation_df
annotation_df <- annotation_df %>%
  left_join(cytobands_hg38 %>%
              select(chrom, start, end, band), by = c("chr" = "chrom")) %>%
  mutate(band = ifelse(pos >= start & pos <= end, band, NA)) %>%
  select(-start, -end)  # Drop the start and end columns from the final output

# View the result
head(annotation_df)



######################### Another way ##############
library(dplyr)

# Step 1: Create a new column in annotation_df to store the matching band
annotation_df$band <- NA

# Step 2: Group cytobands by chromosome
cytobands_grouped <- cytobands_hg38 %>%
  group_by(chrom) %>%
  arrange(start, end)  # Optional: arrange cytobands in order of start and end positions

# Step 3: Loop through each row of annotation_df
for (i in 1:nrow(annotation_df)) {
  # Get the row's chromosome and position
  chr <- annotation_df$chr[i]
  pos <- annotation_df$pos[i]
  
  # Find matching cytobands for the chromosome
  matching_cytobands <- cytobands_grouped %>%
    filter(chrom == chr)
  
  # Check if pos falls within the start and end range of any cytoband
  matching_band <- matching_cytobands %>%
    filter(start <= pos & end >= pos) %>%
    pull(band)
  
  # If a matching band is found, add it to the annotation_df row
  if (length(matching_band) > 0) {
    annotation_df$band[i] <- matching_band[1]  # Only add the first matching band
  }
}



# Check the result
View(annotation_df)



# save table
writexl::write_xlsx(annotation_df, "./Output/annotation_0.,01_cytoband.xlsx")
```

# retreat tables
```{r}
Swan_0.01_Beta_rownames <- cbind(CpGs = rownames(ratio_geno_Swan_0.01_NoSNP_Beta_df), ratio_geno_Swan_0.01_NoSNP_Beta_df)
writexl::write_xlsx(Swan_0.01_Beta_rownames, "./Output/2-Beta_values_SWAN_0.01.xlsx", col_names = TRUE)

M_values_0.01_df_rownames <- cbind(CpGs = rownames(M_values_0.01_df), M_values_0.01_df)
writexl::write_xlsx(M_values_0.01_df_rownames, "./Output/3-M_values_SWAN_0.01.xlsx", col_names = TRUE)


annotated_with_betas_rownames <- cbind(CpGs = rownames(annotated_with_betas_df), annotated_with_betas_df)
writexl::write_xlsx(annotated_with_betas_rownames, "./Output/4-annotation_0.01_with_betas.xlsx", col_names = TRUE)

CpGs_CLDN10_with_rownames <- cbind(CpGs = rownames(CpGs_CLDN10), CpGs_CLDN10)
writexl::write_xlsx(CpGs_CLDN10_with_rownames, "./Output/5-CpGs_of_CLDN10.xlsx", col_names = TRUE)





# the 3 excel tables are already created --> load the excel tables
library(readxl)


annotated_with_betas_df <- read_excel("./Output/4-annotation_0.01_with_betas.xlsx", col_names = TRUE)
CpGs_CLDN10 <- read_excel("./Output/CpGs_of_CLDN10.xlsx", col_names = TRUE)
ratio_geno_Swan_0.01_NoSNP_Beta_df <- read.excel("./Output/2-Beta_values_SWAN_0.01", col_names= TRUE)
M_values_0.01_df <- read_excel("./Output/3-M_values_SWAN_0.01.xlsx", col_names = TRUE)
```