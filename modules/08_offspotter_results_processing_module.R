# offtargets_import_module.R

# This module processes off-target prediction files generated by tools
# like Cas9-Designer or similar. It reads multiple tab-separated files,
# combines them, cleans the data, and filters out on-target hits
# (i.e., sequences with zero mismatches).
# The final combined and processed table is displayed and can be downloaded.

# Author: Ghazal Sinjar
# Date: 13.04.2025 (Updated for project_output_dir)

# Libraries
library(shiny)
library(dplyr) # For data manipulation (filter, select, mutate, bind_rows)
library(readr) # For read_delim
library(DT) # For interactive data tables
library(writexl) # For writing Excel files
library(stringr) # For string manipulation (str_match)
library(tools) # For file_path_sans_ext
library(bslib) # For layout_sidebar, card
library(conflicted) # For managing function conflicts
'conflict_prefer("filter", "dplyr")
conflict_prefer("select", "dplyr")
conflict_prefer("mutate", "dplyr")
conflict_prefer("col_factor", "readr") # Added this for completeness if readr col_types are used'

offtargetsUI <- function(id) {
  ns <- NS(id)
  
  layout_sidebar(
    fillable = TRUE,
    sidebar = sidebar(
      h4("Input Data"),
      textInput(ns("directory_path"), "Directory Path:", placeholder = "e.g. C:\\path\\to\\data"),
      textAreaInput(ns("guide_file_names"), "Guide File Names (one per line):",
                    placeholder = "e.g.,\nguide1.txt\nguide2a.txt", rows = 5),
      p(tags$small("Note: Ensure your guide files are tab-separated and properly named.")),
      actionButton(ns("run_processing"), "Process Guide Files into one file", class = "btn-primary"),
      hr(),
      conditionalPanel(
        condition = paste0("output['", ns("tableReady"), "'] === true"),
        h4("Download Results"),
        selectInput(ns("download_format"), "Select Format:", choices = c("CSV", "Excel")),
        downloadButton(ns("download_data"), "Download", class = "btn-success")
      )
    ),
    
    div(
      style = "padding-left: 15px; padding-right: 15px;",
      layout_columns(
        col_widths = c(12),
        card(
          card_header("Off-targets File Processing Status"),
          card_body(uiOutput(ns("status_output_card_body")))
        ),
        div(
          h5("Combined all guides offtargets"),
          uiOutput(ns("row_count_text")),
          DTOutput(ns("offtargets_table"), width = "100%")
        )
      )
    )
  )
}


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# SERVER FUNCTION
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#' @param id Module ID.
#' @param project_output_dir A reactive expression for the project's main output directory path.
#' @return A reactive expression containing the combined and processed off-targets data frame.
offtargetsServer <- function(id, project_output_dir = reactive(NULL)) { 
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    output_messages <- reactiveVal(list())
    processed_data_df <- reactiveVal(NULL) # Changed name to clarify it holds the data.frame
    
    # Reactive to indicate if the table is ready for download
    output$tableReady <- reactive({
      !is.null(processed_data_df())
    })
    outputOptions(output, "tableReady", suspendWhenHidden = FALSE)
    
    observeEvent(input$run_processing, {
      output_messages(list())
      processed_data_df(NULL) # Initialize to NULL
      
      msgs <- list()
      all_guides <- list()
      
      dir_path <- gsub("\\\\", "/", input$directory_path) # Normalize path separators
      msgs <- append(msgs, paste0("ðŸ› ï¸ Processing started... Directory: ", dir_path))
      
      if (!dir.exists(dir_path)) {
        msgs <- append(msgs, "âŒ Error: The path you provided doesn't exist.")
        output_messages(msgs)
        return()
      }
      
      file_names <- strsplit(input$guide_file_names, "\\s+")[[1]] # Split by any whitespace
      file_names <- file_names[file_names != ""] # Remove empty strings if any
      
      if (length(file_names) == 0) {
        msgs <- append(msgs, "âŒ Error: No guide file names provided.")
        output_messages(msgs)
        return()
      }
      
      col_names <- c("Chrom", "Strand", "Start", "End", "Given query", "Actual genomic hit",
                     "Number_of_mismatches", "Pre-mRNA (Unspliced)", "mRNA (5UTR)",
                     "mRNA (CDS)", "mRAN (3UTR)", "lincRNA (Unspliced)",
                     "lincRNA (Spliced)", "GC content")
      
      withProgress(message = "Processing off-target files...", value = 0, {
        for (i in seq_along(file_names)) {
          file_name <- file_names[i]
          file_path <- file.path(dir_path, file_name)
          
          incProgress(i / (length(file_names) * 4), detail = paste("Reading", file_name, "..."))
          msgs <- append(msgs, paste0("ðŸ” Reading file: ", file_path))
          
          guide_data <- tryCatch({
            read_delim(file_path, delim = "\t", col_names = FALSE, show_col_types = FALSE)
          }, error = function(e) {
            msgs <<- append(msgs, paste0("âŒ Step 1 - Reading '", file_name, "' failed: ", e$message))
            return(NULL)
          })
          if (is.null(guide_data)) next
          msgs <- append(msgs, paste0("âœ… Step 1 - '", file_name, "' read successfully"))
          
          incProgress(i / (length(file_names) * 4) + 0.1, detail = paste("Verifying columns for", file_name, "..."))
          if (ncol(guide_data) != length(col_names)) {
            msgs <- append(msgs, paste0("âŒ Step 2 - Column mismatch for '", file_name, "': expected ", length(col_names), ", got ", ncol(guide_data)))
            next
          }
          msgs <- append(msgs, paste0("âœ… Step 2 - '", file_name, "' column count verified"))
          
          incProgress(i / (length(file_names) * 4) + 0.2, detail = paste("Processing data for", file_name, "..."))
          processed <- tryCatch({
            colnames(guide_data) <- col_names
            guide_data <- guide_data[, !colnames(guide_data) %in% "GC content"] # Remove GC content column
            guide_data$guide <- tools::file_path_sans_ext(file_name) # Add guide name from filename
            guide_data$Start <- as.integer(guide_data$Start)
            guide_data$End <- as.integer(guide_data$End)
            guide_data$Start_minus_70 <- guide_data$Start - 70
            guide_data$End_plus_70 <- guide_data$End + 70
            guide_data$Number_of_mismatches <- as.integer(guide_data$Number_of_mismatches)
            guide_data
          }, error = function(e) {
            msgs <<- append(msgs, paste0("âŒ Step 3 - Processing '", file_name, "' failed: ", e$message))
            return(NULL)
          })
          if (is.null(processed)) next
          msgs <- append(msgs, paste0("âœ… Step 3 - '", file_name, "' data processed"))
          
          all_guides[[file_name]] <- processed
          msgs <- append(msgs, paste0("âœ… Step 4 - '", file_name, "' data stored"))
        }
        
        incProgress(0.7, detail = "Combining all off-targets...")
        msgs <- append(msgs, "ðŸ“¦ Step 5 - All off-targets in one file...")
        combined <- tryCatch({
          if (length(all_guides) > 0) {
            bind_rows(all_guides)
          } else {
            stop("No valid guide files were processed.")
          }
        }, error = function(e) {
          msgs <<- append(msgs, paste0("âŒ Step 5a - Combining failed: ", e$message))
          return(NULL)
        })
        if (is.null(combined)) {
          output_messages(msgs)
          return()
        }
        msgs <- append(msgs, "âœ… Step 5a - Guides combined")
        
        incProgress(0.8, detail = "Filtering out on-targets and adding IDs...")
        final <- tryCatch({
          combined %>%
            dplyr::filter(Number_of_mismatches != 0) %>% # Filter out on-targets (0 mismatches)
            dplyr::mutate(
              # Extract guide number for ID creation
              guide_num = stringr::str_match(guide, "(?i)guide([[:alnum:]]+)")[, 2],
              # Create unique ID for each off-target
              ID = paste0("G", guide_num, ".M", Number_of_mismatches, ".chr", Chrom, "_", Start)
            ) %>%
            dplyr::select(-guide_num) %>% # Remove temporary guide_num column
            # Reorder columns for better readability
            dplyr::select(ID, guide, Chrom, Start, End, Number_of_mismatches,
                          Start_minus_70, End_plus_70, dplyr::everything())
        }, error = function(e) {
          msgs <<- append(msgs, paste0("âŒ Step 5b - Filtering failed: ", e$message))
          return(NULL)
        })
        
        
        if (is.null(final)) {
          output_messages(msgs)
          return()
        }
        if (nrow(final) == 0) {
          msgs <- append(msgs, "âš ï¸ Warning: After filtering, no off-targets (mismatches > 0) were found.")
          # Still set processed_data_df to an empty data frame so table displays properly
          processed_data_df(final)
          output_messages(msgs)
          incProgress(1)
          return()
        }
        
        msgs <- append(msgs, "âœ… Step 5b - Filtered out on-targets and generated IDs")
        
        # âœ… Step 6: Save as RDS in project_output_dir/intermediate_data ------------------------
        # ONLY execute if project_output_dir is provided and not NULL
        if (!is.null(project_output_dir())) { 
          output_dir_full <- file.path(project_output_dir(), "Off-targets_results") 
          if (!dir.exists(output_dir_full)) dir.create(output_dir_full, recursive = TRUE)
          
          # Construct safe filename from guide names and add date
          # Use first few guide names for a concise filename or a generic one if too many
          if (length(file_names) > 3) {
            safe_filename_base <- paste0("offtargets_combined_", format(Sys.Date(), "%Y%m%d"))
          } else {
            safe_filename_base <- paste0("offtargets_", gsub("[^A-Za-z0-9_]", "_", paste0(tools::file_path_sans_ext(file_names), collapse = "_")), "_", format(Sys.Date(), "%Y%m%d"))
          }
          
          output_path <- file.path(output_dir_full, paste0(safe_filename_base, ".csv"))
          
          incProgress(0.9, detail = "Saving processed data...")
          tryCatch({
            write.csv(final, output_path, row.names = FALSE) # Changed saveRDS to write.csv
            msgs <- append(msgs, paste0("ðŸ’¾ Step 6 - Saved processed data as csv at: ", output_path))
          }, error = function(e) {
            msgs <<- append(msgs, paste0("âŒ Step 6 - Saving csv failed: ", e$message))
          })
        } else {
          msgs <- append(msgs, "â„¹ï¸ Step 6 - Skipping saving data: Project output directory not provided. To save the table click on the download button")
        }
        
        processed_data_df(final) # Store the final data.frame in this reactiveVal
        output_messages(msgs)
        incProgress(1)
      }) # End withProgress
    })
    
    output$status_output_card_body <- renderUI({
      tags$ul(
        style = "padding-left: 1.2em; margin: 0;",
        lapply(output_messages(), function(msg) {
          tags$li(style = "margin-bottom: 4px;", msg)
        })
      )
    })
    
    output$offtargets_table <- DT::renderDT({
      req(processed_data_df()) 
      datatable(processed_data_df(), options = list(pageLength = 10, scrollX = TRUE)) 
    })
    
    output$row_count_text <- renderUI({
      req(processed_data_df()) 
      n <- nrow(processed_data_df()) 
      HTML(paste0("<p><strong>", n, "</strong> off-targets found</p>"))
    })
    
    output$download_data <- downloadHandler(
      filename = function() {
        # Construct filename based on input guide files and date
        file_names <- strsplit(input$guide_file_names, "\\s+")[[1]]
        file_names <- file_names[file_names != ""] # Remove empty strings if any
        
        if (length(file_names) > 3) {
          base_name <- paste0("offtargets_combined_", format(Sys.Date(), "%Y%m%d"))
        } else {
          base_name <- paste0("offtargets_", gsub("[^A-Za-z0-9_]", "_", paste0(tools::file_path_sans_ext(file_names), collapse = "_")), "_", format(Sys.Date(), "%Y%m%d"))
        }
        
        ext <- if (input$download_format == "Excel") "xlsx" else "csv"
        paste0(base_name, ".", ext)
      },
      content = function(file) {
        df <- processed_data_df()
        if (input$download_format == "Excel") {
          if (!requireNamespace("writexl", quietly = TRUE)) {
            stop("Package 'writexl' is required for Excel export. Please install it.")
          }
          writexl::write_xlsx(df, path = file)
        } else {
          write.csv(df, file, row.names = FALSE)
        }
      }
    )
    
    return(processed_data_df)
  })
}



# app.R

library(shiny)
library(DT)
library(readr)
library(dplyr)
library(stringr)


ui <- page_navbar(
  title = "EPIC Array Pipeline",
  theme = bs_theme(version = 5, bootswatch = "flatly"),
  nav_panel("Offtargets Import Test",
            offtargetsUI("myOfftargetModule"))
)

server <- function(input, output, session) {
  # Call the module
  processed_data <- offtargetsServer( id="myOfftargetModule", project_output_dir= reactive({"./epic_test"}))
  
  # Optional: observe or debug whatâ€™s returned from the module
  observe({
    req(processed_data())
    cat("âœ… Test App: Processed data returned with", nrow(processed_data()), "rows\n")
  })
}

shinyApp(ui = ui, server = server)